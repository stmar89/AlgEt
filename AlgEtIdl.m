/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtIdl, 3;

/*TODO:

*/

declare type AlgEtIdl;
declare attributes AlgEtIdl : Index, //stores the index
                              Order, //order of definition. it might be smaller than the multiplicator ring
                              Algebra,
                              MultiplicatorRing,
                              Generators,
                              ZBasis,
                              IsPrime,
                              PrimesAbove,
                              Factorization,
                              Hash;
 

import "AlgEtOrd.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQToA , meet_zbasis ;

/*TODO
    - ChineseRemThm to be fixed
    - a function MinimalGenerators
    - check which attributes should I pass when I create a new ideal (eg in *,+,colon,...)
    - in '*' should pass Factorization
    - clean the code
    - comment ColonIdeal
    - check equality and Hashing
*/

//----------
// Creation functions
//----------

CreateAlgEtOrdIdl:=function(S,gens)
// Given S::AlgEtOrd and some generateors creates the new object 
// Here we just assign the generators. we do not compute the Zbasis unless necessary!
    A:=Algebra(S);
    I:=New(AlgEtIdl);
    I`Algebra:=A;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(A) then
        vprintf AlgEtIdl, 2: "too many gens";
        gens:=[g*s : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(A);
        M:=MatrixAtoQ(gens);
        d:=Integers()!Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        zb:=MatrixQToA(A,P);
        assert #zb eq AbsoluteDimension(A);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    return I;
end function;

intrinsic Ideal(S::AlgEtOrd, gens::SeqEnum) -> AlgEtIdl
{Creates an ideal of S, generated by gens.}
    A:=Algebra(S);
    gensA:=[];
    for g in gens do
        bool,gA:=IsCoercible(A,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensA,gA);
    end for;
    return CreateAlgEtOrdIdl(S,gensA);
end intrinsic;

intrinsic Ideal(S::AlgEtOrd, gen::Any) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,[gen]);
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::AlgEtElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::AlgEtElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::RngIntElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::RngIntElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::FldRatElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::FldRatElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic Print(I::AlgEtIdl)
{Prints the ideal.}
  printf"Ideal of %o", Order(I);
end intrinsic;

//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtOrd,I::AlgEtIdl) -> AlgEtIdl
{Given an S-ideal I and an order T, returns the extension IT as a T-ideal. Note that if T is in S, then IT=I}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        id:=Ideal(T,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=I`MultiplicatorRing; //..as well as the MultiplicatorRing
        end if;
        return id;
    else //in this case Order(I) is strictly contained in T
        return Ideal(T,Generators(I));
    end if;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(I::AlgEtIdl) -> AlgEt
{Returns the Ã©tale algebra in which the ideal lives.}
    return I`Algebra;
end intrinsic;

intrinsic Order(I::AlgEtIdl) -> AlgEtOrd
{Returns the order of definition of the ideal.}
    return I`Order;
end intrinsic;

intrinsic ZBasis(I::AlgEtIdl)->SeqEnum[AlgEtElt]
{Returns a Z-basis of the ideal.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        A:=Algebra(I);
        S:=Order(I);
        gens:=[g*s : g in Generators(I) , s in ZBasis(S) ];
        if #Generators(I) eq 1 then
            zb:=gens; //gens is a ZBasis of I
        else
            dim:=AbsoluteDimension(A);
            M:=MatrixAtoQ(gens);
            d:=Integers()!Denominator(M);
            P:=hnf(crQZ(d*M));
            P:=(1/d)*crZQ(P);
            d:=Denominator(P); //this d might be different from Denomintor(M)
            hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
            zb:=MatrixQToA(A,P);
            assert #zb eq AbsoluteDimension(A);
            I`Hash:=hash;
        end if;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic Generators(I::AlgEtIdl) -> SeqEnum[AlgEtElt]
{Returns the generators of the ideal.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(Algebra(I));
    return I`Generators;
end intrinsic;

intrinsic myHash(I::AlgEtIdl)->RngInt
{Hash function}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(Algebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*hnf(crQZ(d*P));
        assert2 IsUpperTriangular(P);
        d:=Integers() ! Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Binary operations
//----------

intrinsic 'eq'(I::AlgEtIdl , J::AlgEtIdl ) -> BoolElt
{Equality testing.}
    require Algebra(I) cmpeq Algebra(J) : "The ideals are not in the same algebra.";
    require Order(I) cmpeq Order(J) : "The ideals are not over the same order.";
    if (assigned I`Generators and assigned J`Generators and Generators(I) eq Generators(J))
        or myHash(I) eq myHash(J) then
        // we do not check over the ZBasis, because it will turn out to be slower, too many elments in there.
        out:=true;
    else
        out:=false;
    end if;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtIdl) do
            if assigned I``att and not assigned J``att then
                J``att:=I``att;
            elif assigned J``att and not assigned I``att then
                I``att:=J``att;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtIdl , J::AlgEtIdl ) -> BoolElt
{Equality testing}
    return not I eq J;
end intrinsic;
/* Continue fro here


intrinsic 'in'(x::AlgEtElt , I::AlgEtOrdIdl ) -> BoolElt
{ returns if x is in I }
    require Algebra(x) eq Algebra(I) : "the elements must lie in the same algebra of definition";
    if assigned I`Generators and x in I`Generators then 
        return true;
    end if;
    if assigned I`ZBasis and x in I`ZBasis then 
        return true;
    end if;
    mat := Coordinates([x], ZBasis(I))[1];
    return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

intrinsic '+'(I::AlgEtOrdIdl , J::AlgEtOrdIdl ) -> AlgEtOrdIdl
{ returns the sum of two ideals }
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    if I eq J then
        return I;
    elif I subset J then
        return J;
    elif J subset I then
        return I;
    end if;
    S:=Order(I);
    gens:=Generators(I) cat Generators(J);
    return Ideal(S,gens);
end intrinsic;

intrinsic '*'(I::AlgEtOrdIdl , J::AlgEtOrdIdl ) -> AlgEtOrdIdl
{ returns the product of two ideals }
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    S:=Order(I);
    gI:=Generators(I);
    gJ:=Generators(J);
    if #gI eq 1 then //better for passing the attributes
        return J*gI[1];
    elif #gJ eq 1 then
        return I*gJ[1];
    else
        gens:=[i*j : i in gI, j in gJ ];
        return Ideal(S,gens);
    end if;
end intrinsic;

intrinsic '*'(I::AlgEtOrdIdl , x::AlgEtElt ) -> AlgEtOrdIdl
{ returns x*I }
    bool,x:=IsCoercible(Algebra(I),x);
    if not bool then
        error "the element must be in the same algebra of I";
    else
        S:=Order(I);
        gens:=[i*x : i in Generators(I) ];
        id:=Ideal(S,gens);
        if assigned I`ZBasis then
            id`ZBasis:=[x*z : z in ZBasis(I)];
        end if;
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        return id;
    end if;
end intrinsic;

intrinsic '*'(x::AlgEtElt, I::AlgEtOrdIdl) -> AlgEtOrdIdl
{ returns x*I }
    return I*x;
end intrinsic;

intrinsic '*'(x::RngIntElt, I::AlgEtOrdIdl) -> AlgEtOrdIdl
{ returns x*I }
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtOrdIdl, x::RngIntElt) -> AlgEtOrdIdl
{ returns x*I }
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(x::FldRatElt, I::AlgEtOrdIdl) -> AlgEtOrdIdl
{ returns x*I }
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtOrdIdl, x::FldRatElt) -> AlgEtOrdIdl
{ returns x*I }
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '^'(I::AlgEtOrdIdl, n::RngIntElt) -> AlgEtOrdIdl
{ compute the nth power of an ideal }
    S:=Order(I);
    power_positive:=function(I, n)
        id := I;
        output := OneIdeal(S);
        bin_exp:=IntegerToSequence(n,2);
        for i in [1..#bin_exp] do
            if bin_exp[i] eq 1 then
                output *:= id;
            end if;
            if i lt #bin_exp then
                id := id*id;
            end if;
        end for;
        return output;
    end function;
    if n eq 0 then
        return OneIdeal(S);
    elif n eq 1 then
        return I;
    elif n eq 2 then
        return I * I;
    else
        if n gt 0 then
            return power_positive(I,n);
        end if;
        if n lt 0 then
            require IsInvertible(I) :"the ideal must be invertible";
            invI:=ColonIdeal(S,I);
            return power_positive(invI,-n);
        end if;
    end if;
end intrinsic;

intrinsic 'meet'(I::AlgEtOrdIdl, S::AlgEtOrd) -> AlgEtOrdIdl
{given an ideal I of S, return S cap I}
    assert Algebra(I) eq Algebra(S);
    require Order(I) eq S: "the first argument must be an ideal of the second argument";
    return S meet I;
end intrinsic;

intrinsic 'meet'(S::AlgEtOrd,I::AlgEtOrdIdl) -> AlgEtOrdIdl
{given an ideal I of S, return S cap I}
    assert Algebra(I) eq Algebra(S);
    require Order(I) eq S: "the second argument must be an ideal of the first argument";
    output := OneIdeal(S) meet I;
    return output;
end intrinsic;

intrinsic 'meet'(I::AlgEtOrdIdl, J::AlgEtOrdIdl) -> AlgEtOrdIdl
{given ideals I and J, return J cap I}
// this code is inspired by H.Cohen "Advanced Topics in ...", page 36.]
// note that the hnf in Magma is not the same as in the book. This is why the matrix M and P are take in a slightly different way compared to the refernce.
    require Algebra(I) eq Algebra(J): "the ideals must lie in the same algebra";
    require Order(I) eq Order(J): "the ideals must be defined over the same order";
    A:=Algebra(I);
    if I subset J then 
        return I;
    end if;
    if J subset I then
        return J;
    end if;
    N:=#ZBasis(I);
    MI:=crZQ(Matrix(ZBasis(I)));
    MJ:=crZQ(Matrix(ZBasis(J)));
    dI:=Integers() ! Denominator(MI);
    dJ:=Integers() ! Denominator(MJ);
    d:=LCM(dI,dJ);
    MI:=crQZ(d*MI);
    MJ:=crQZ(d*MJ);
    MZ:=ZeroMatrix(Integers(),N,N);
    M:=Matrix(HorizontalJoin(VerticalJoin(MI,MJ),VerticalJoin(MI,MZ)));
    M:=hnf(M);
    //the hnf of I meet J is the lower-right quadrant of M
    P:=Matrix(N,N,[M[i,j] : i,j in [N+1..2*N]]);
    P:=(1/d)*crZQ(P);
    zb:=MatrixToA(A,P);
    id:=Ideal(Order(I),zb);
    id`ZBasis:=zb;
    
    d2:=Integers() ! Denominator(P);
    entries:=[d2] cat [(Integers()!(d2*P[i,j])) : j in [i..N] , i in [1..N]];
    hash:=Integers() ! eval(&cat[Sprint(s) : s in entries]);
    id`Hash:=hash;
    return id;
end intrinsic;

intrinsic 'eq'(I::AlgEtOrdIdl, S::AlgEtOrd) -> BoolElt
{return if I eq S. I needs to be an ideal of S}
  assert Algebra(I) cmpeq Algebra(S);
  if Index(S, I) eq 1 then
      return I eq OneIdeal(S);
  else
      return false;
  end if;
end intrinsic;

intrinsic 'eq'(S::AlgEtOrd,I::AlgEtOrdIdl) -> BoolElt
{return if I eq S. I needs to be an indeal of S}
    return I eq S;
end intrinsic;

intrinsic 'subset'(S::AlgEtOrd,I::AlgEtOrdIdl) -> BoolElt
{given an ideal I of S, return if S subseteq I}
    assert Algebra(I) cmpeq Algebra(S);
    require Order(I) eq S: "the second argument must be an ideal of the first argument";
    return OneIdeal(S) subset I;
end intrinsic;

intrinsic 'subset'(I::AlgEtOrdIdl,S::AlgEtOrd) -> BoolElt
{given an ideal I of S, return if I subseteq S}
    assert Algebra(I) cmpeq Algebra(S);
    require Order(I) eq S: "the first argument must be an ideal of the second argument";
    return I subset OneIdeal(S);
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtOrdIdl, I2 :: AlgEtOrdIdl) -> BoolElt
{Checks if the first argument is inside the second. The ideals need to be fractional}
  require Order(I1) eq Order(I2) : "The ideals must be in the same order.";
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  mat := Matrix(Coordinates(Generators(I1), ZBasis(I2)));
  return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

//----------
// Other
//----------
 
intrinsic MultiplicatorRing(I::AlgEtOrdIdl) -> AlgEtOrd
{return a Z-basis of the ideal}
    if not assigned I`MultiplicatorRing then
        R:=Order(I);
        if #Generators(I) eq 1 then
            return R;
        end if;
        A:=Algebra(I);
        zbS:=ZBasis(ColonIdeal(I,I));
        S:=Order(zbS : Check:=true );
        if assigned R`OverOrders then
        //this is to move the attributes
            ooR:=FindOverOrders(R);
            pos:=Index(ooR,S);
            S:=ooR[pos];
        end if;
        I`MultiplicatorRing:=S;
    end if;
    return I`MultiplicatorRing;
end intrinsic;

intrinsic IsProductOfIdeals(I::AlgEtOrdIdl) -> BoolElt, Tup
{return if the argument is a product of ideals in number fields, and if so return also the sequence of these ideals (in the appropriate orders)}
    O:=MultiplicatorRing(I);
    A:=Algebra(O);
    test,O_asProd:=IsProductOfOrders(O);
    I_asProd:=<>;
    if test then
        idem:=OrthogonalIdempotents(A);
        for i in [1..#A`NumberFields] do
            L:=A`NumberFields[i];
            gen_L:=[(x*idem[i])@@L[2]: x in Generators(I)];
            I_L:=ideal<O_asProd[i]|gen_L>;
            Append(~I_asProd,I_L);
        end for;
        return true, I_asProd;
    else
        return false,<>;
    end if;
end intrinsic;

intrinsic TraceDualIdeal(I::AlgEtOrdIdl) -> AlgEtOrdIdl
{ returns the trace dual ideal of an ideal in an order in an associative algebra }
    A:=Algebra(I);
    S:=Order(I);
    B:=[z`AlgAssElt : z in ZBasis(I)];
    n:=#B;
    Q:=MatrixRing(RationalField(), n)![Trace(B[i]*B[j]): i, j in [1..n] ];
    QQ:=Q^-1;
    BB:=[A ! (&+[ (QQ[i,j]*B[j]): j in [1..n]]) : i in [1..n]] ;
    It:=Ideal(S,BB);
    It`ZBasis:=BB; //we know that BB is a ZBasis
    return It;
end intrinsic;

intrinsic TraceDualIdeal(O::AlgEtOrd) -> AlgEtOrdIdl
{ returns the trace dual ideal of an order in an associative algebra }
    return TraceDualIdeal(OneIdeal(O));
end intrinsic;

intrinsic MinimalInteger(I::AlgEtOrdIdl) -> RngIntElt
{returns the smallest integer contained in the ideal I}
    require IsIntegral(I): "the ideal must be integral";
    coord:=Coordinates([One(Algebra(I))],ZBasis(I))[1];
    min:=LCM([ Denominator(c) : c in Eltseq(coord)]);
    return min;
end intrinsic;

intrinsic Random(I::AlgEtOrdIdl : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtElt
{ Returns a random (small coefficient) element of I. 
  The range of the random coefficients can be increased by giving the optional argument CoeffRange.
  One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
    B := ZBasis(I);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-CoeffRange..CoeffRange])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-CoeffRange..CoeffRange])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic CoprimeRepresentative(I::AlgEtOrdIdl,J::AlgEtOrdIdl) -> AlgEtElt
{return an element x such that x*I is an integral ideal coprime with J. The first ideal must be invertible and the second should be integral}
    require IsIntegral(J) : "the second ideal must be integral";
    S:=Order(I);
    require S eq Order(J): "the ideals must be defined over the same order";
    require IsInvertible(I): "The first ideal must be invertible";
    invI:=ColonIdeal(S,I);
    repeat
        x:=Random(invI);
    until IsCoprime(x*I,J); //integrality of x*I is checked in IsCoprime
    return x;
end intrinsic;

//  intrinsic ChineseRemainderTheorem(I::AlgEtOrdIdl,J::AlgEtOrdIdl,a::AlgEtElt,b::AlgEtElt)-> AlgEtElt
//  {given two coprime ideals I and J of S, two elements a,b in S, finds e such that (e-a) in I and (e-b) in J}
//      require IsCoprime(I,J) : "the ideals must be coprime";
//      S:=Order(I);
//      require a in S and b in S:"the elements must lie in order of definition of the ideals";
//      require S eq Order(J): "the ideals must be of the same order";
//      K:=Algebra(S);
//      n:=Degree(K);
//      //I need to modify the ZBasis(S) in a way that One(K) is the first element of Zbasis_S
//      Zbasis_S:=ZBasis(S);
// //      pos:=Position(ZBasis(S),One(K));
// //      if pos ne 1 then
// //          if pos eq 0 then //One(K) not in Zbasis_S
// //              coord:=Coordinates([One(K)],Zbasis_S)[1];
// //              pos:=Position(coord,1);
// //              if pos eq 0 then
// //                  pos:=Position(coord,-1);
// //              end if;
// //  //test
// //  if pos eq 0 then coord; end if;
// //  //assert pos ne 0;
// //  //replacing Zbasis_S[pos] with One(K) since they generate the same Z-Span
// //  end if; 
// //          temp:=Zbasis_S[1];
// //          Zbasis_S[1]:=One(K);
// //          Zbasis_S[pos]:=temp;
// //      end if;
//      M:=Matrix(Zbasis_S);
//      Minv:=M^-1;
//      A:=ChangeRing(Matrix(ZBasis(I))*Minv,Integers());
//      B:=ChangeRing(Matrix(ZBasis(J))*Minv,Integers());
//      I_min:=MinimalInteger(I);
//      J_min:=MinimalInteger(J);
//      g,c1,d1:=XGCD(I_min,J_min);
//      if g ne 1 then
//          C:=VerticalJoin(A,B);
//          H,U:=HermiteForm(C); //U*C = H;
//          z:=ZeroMatrix(Integers(),n,n);
//          s:=ScalarMatrix(n,1);
//          assert2 H eq VerticalJoin(s,z);
//          P:=VerticalJoin(HorizontalJoin(z,s),HorizontalJoin(s,z));
//          U1:=Transpose(U)*P; //I need the (n+1)st column of U1
//          Z:=Transpose(U1)[n+1];
//          X:=Matrix(Integers(),1,n,[Z[i] : i in [1..n]]);
//          Y:=X*A;
//          c:=&+[Y[1,i]*Zbasis_S[i] : i in [1..n]];
//          assert2 c in I;
//          d:=One(K)-c;
//          assert2 d in J;
//      else
//          //g:=c1*I_min+d1*J_min
//          c:=c1*I_min;
//          d:=d1*J_min;
//      end if;
//      e:=a*d+b*c;
//      assert e-a in I;
//      assert e-b in J;
//      return e;
//  end intrinsic;

intrinsic ResidueRing(S::AlgEtOrd,I::AlgEtOrdIdl) -> GrpAb , Map
{given an integral ideal I of S, returns the abelian group S/I and the epimorphism pi:S -> S/I (with inverse map). Important: the domain of pi is the Algebra of S, since the elements of S are usually expressed al elements of A. For eg Parent(Random(S)) = Algebra(S)}
    require Order(I) eq S : "wrong order";
    require IsIntegral(I): "I must be an integral ideal of S";
    A:=Algebra(S);
    N:=Degree(A);
    F:=FreeAbelianGroup(N);
    matS:=Transpose(Matrix(ZBasis(S)));
    matP:=Transpose(Matrix(ZBasis(I)));
    S_to_F:=function(x0)
        assert Parent(x0) eq A;
        x_inS:=Coordinates([x0],ZBasis(S));
        return (F ! Eltseq(x_inS)) ;
    end function;
    F_to_S:=function(y)
        clmn_vec_y:=Transpose(Matrix(Vector(Eltseq(y))));
        y_inA:=&+[ZBasis(S)[i]*Eltseq(clmn_vec_y)[i] : i in [1..N]];
        return y_inA;
    end function;
    StoF:=map< A -> F | x :-> S_to_F(x), y :-> F_to_S(y)>;
    rel:=[F ! Eltseq(x) : x in Rows(Transpose(matS^-1 * matP))];
    Q,q:=quo<F|rel>; //Q=S/I
    m:=StoF*q; //m is a map from S to Q
    assert #Q eq Index(S,I);
    assert2 forall{x : x in ZBasis(I) | m(x) eq Zero(Q)};
    assert2 forall{x : x in ZBasis(S) | ((m(x))@@m - x) in I};
    return Q,m;
end intrinsic;

intrinsic IsCoprime(I::AlgEtOrdIdl,J::AlgEtOrdIdl) -> BoolElt
{given two integral ideals I and J of an order S, returns whether I+J=R}
    require Algebra(I) cmpeq Algebra(J) : "the ideals must lie in the same algebra";
    S:=Order(J);
    require Order(I) eq S: "the ideals must be over the same order";
    require IsIntegral(I) and IsIntegral(J): "the ideals must be integral";
    return (One(S) in I+J);
end intrinsic;

intrinsic IsIntegral(I::AlgEtOrdIdl) -> BoolElt
{returns wheter the ideal I of S is integral, that is I \subseteq S}
    S:=Order(I);
    return I subset S;
end intrinsic;

intrinsic MakeIntegral(I::AlgEtOrdIdl) -> AlgEtOrdIdl
{given a fractional S ideal I, returns the ideal d*I,d when d is the smallest integer such that d*I is integral in S}
    if IsIntegral(I) then return I; end if;
    S:=Order(I);
    d:=Denominator(ChangeRing(Matrix(Coordinates(Generators(I),ZBasis(S))),Rationals()));
    return d*I, d;
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtOrdIdl) -> FldRatElt
{given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module}
  if not assigned T`Index then
    matT := Matrix(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtOrdIdl, I::AlgEtOrdIdl) -> FldRatElt
{given fractional ideals J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I]}
    require Order(I) eq Order(J): "the ideals must be of the same order";
  return Index(I)/Index(J);
end intrinsic;

intrinsic Index(S::AlgEtOrd, I::AlgEtOrdIdl) -> FldRatElt
{given and ideal I of an order S returns [S:I] = [S:S cap I]/[I : S cap I] }
    require Order(I) eq S: "the ideal must be of the appropriate order";
    return Index(OneIdeal(S), I);
end intrinsic;


//----------
// Factorization and Prime
//----------

function factorizationMaximalOrder(I)
//given an ideal of the maximal order of an algebra, returns the factorization into a product of prime ideals
    O:=Order(I);
    assert IsMaximal(O);
//to be removed
_,OasProd:=IsProductOfOrders(O);
assert forall{OL : OL in OasProd | IsMaximal(OL)};
//
    A:=Algebra(O);
    _,IasProd:=IsProductOfIdeals(I);
    fac:=[]; //this will be the factorization of I
    for i in [1..#A`NumberFields] do
        L:=A`NumberFields[i,1];
        mL:=A`NumberFields[i,2];
        IL:=IasProd[i];
        assert IsMaximal(Order(IL));
        facL:=Factorization(IL);
        for p in facL do
            genPinA:=[mL(x) : x in Basis(p[1],L)] cat [F[2](One(F[1])) : F in A`NumberFields | F[1] ne L];
            P:=Ideal(O,genPinA);
            assert2 IsPrimePower(Integers() ! Index(O,P));
            Append(~fac,<P,p[2]>);
        end for;
    end for;
    assert2 I eq &*[p[1]^p[2] : p in fac];
    return fac;
end function;

intrinsic Factorization(I::AlgEtOrdIdl) -> Tup
{given a proper integral S-ideal I coprime with the conductor of S (hence invertible in S), returns its factorization into a product of primes of S}
    S:=Order(I);
    require IsIntegral(I) and I ne OneIdeal(S): "the argument must be a proper integral ideal";
    if not assigned I`Factorization then    
        if IsMaximal(S) then
        I`Factorization:=factorizationMaximalOrder(I);
        else
            fS:=Conductor(S);
            require IsCoprime(fS,I): "the ideal must be coprime with the conductor of the order of definition";
            O:=MaximalOrder(Algebra(I));
            IO:=O !! I;
            facO:=factorizationMaximalOrder(IO);
            primesO:=[ p[1] : p in facO ];
            primesS:=Setseq({ OneIdeal(S) meet (S!!PO) : PO in primesO }); //this should cancel the doubles
            facS:=<>;
            for i in [1..#primesS] do
                P:=primesS[i];
                P`IsPrime:=true;
                expP:=&+([ pO[2] : pO in facO | (S meet (S!!pO[1])) eq P ]);
                Append(~facS, <P,expP>);
            end for;
            assert2 I eq &*([ p[1]^p[2] : p in facS ]);
            I`Factorization:=facS;
        end if;
     end if;
     return I`Factorization;
end intrinsic;

intrinsic PrimesAbove(I::AlgEtOrdIdl) -> SeqEnum[AlgAssEtOrdIdl]
{given an integral S-ideal, returns the sequence of maximal ideals P of S above I}
    require IsIntegral(I): "the ideal must be integral";
    if not assigned I`PrimesAbove then
        if assigned I`Factorization then
            primes:=[P[1] : P in I`Factorization];
        end if;
        S:=Order(I);
        if I eq OneIdeal(S) then
            primes:=[];
        else
            if IsMaximal(S) then
                O:=S;
                IO:=I;
            else
                O:=MaximalOrder(Algebra(I));
                IO:=O!!I;
            end if;
            fac:=Factorization(IO);
            primes:= Setseq({ OneIdeal(S) meet (S!!PO[1]) : PO in fac });
            assert2 forall{P : P in primes | IsIntegral(P)};
            assert2 forall{P : P in primes | Index(S,P) gt 1};
            for i in [1..#primes] do
                P:=primes[i];
                P`IsPrime:=true;
            end for;
            assert2 forall{P : P in primes | I subset P};
            assert2 forall{P : P in primes | IsPrimePower(Integers() ! Index(S,P))};
        end if;
        I`PrimesAbove:=primes;
    end if;
    return I`PrimesAbove;
end intrinsic;

intrinsic IsPrime(I::AlgEtOrdIdl) -> BoolElt
{given an integral S-ideal, returns if the ideal is a prime fractional ideal of S, that is a maximal S ideal}
    require IsIntegral(I): "the ideal must be integral";
    if not assigned I`IsPrime then
        prim:=PrimesAbove(I);
        if #prim eq 1 and I eq prim[1] then
            bool:=true;
        else
            bool:=false;
        end if;
        I`IsPrime:=bool;
    end if;
    return I`IsPrime;
end intrinsic;

//----------
// ColonIdeals
//----------

intrinsic ColonIdeal(I::AlgEtOrdIdl,J::AlgEtOrdIdl)->AlgEtOrdIdl
{computes the colon ideal (I:J) (as an O-ideal) of two O-ideals}
    A:=Algebra(I);
    O := Order(I);
//for tests: to be removed
         I0:=I;
         J0:=J;
//
    require Order(J) eq O : "the ideals must be of the same order";
    if assigned J`Generators and #J`Generators eq 1 then
        j:=J`Generators[1];
        return (1/j)*I;
    end if;
t0:=Cputime();
// based on jv code
    N:=Dimension(A);
    zbI:=ZBasis(I);
    mIinv:=Matrix(zbI)^-1;
    zbJ:=ZBasis(J);
    M:=VerticalJoin([ Transpose( Matrix([zj*A.i : i in [1..N]])*mIinv) : zj in zbJ] );
    d:=Denominator(M);
    P:=(1/d)*crZQ(hnf(crQZ(d*M)));
    P:=Transpose(P)^-1;
    zbIJ:=MatrixToA(A,P);
    IJ:=Ideal(O,zbIJ);
    IJ`ZBasis:=zbIJ; //we know that zbIJ is a ZBasisA
    t1:=Cputime(t0);
t0:=Cputime();
//tests to be removed
    C := Colon(AssIdeal(I0),AssIdeal(J0));
    C := PseudoMatrix(CoefficientIdeals(C), Matrix(C) * Matrix(PseudoMatrix(AssOrder(O)))^-1 );
    IJtest := O!!ideal<AssOrder(O)|C>;
t2:=Cputime(t0);
//"index",Index(IJtest,IJ);
//ZBasis(IJtest);
//ZBasis(IJ);
    assert IJtest eq IJ;
//t1 le t2;
//
    assert2 IJ*J subset I;
    return IJ;
end intrinsic;

intrinsic ColonIdeal(O::AlgEtOrd,J::AlgEtOrdIdl)->AlgEtOrdIdl
{computes the colon ideal (1*O:J) (as an O-ideal)}
    require Order(J) eq O : "the ideals must be of the same order";
    return ColonIdeal(OneIdeal(O), J);
end intrinsic;

intrinsic ColonIdeal(I::AlgEtOrdIdl,O::AlgEtOrd)->AlgEtOrdIdl
{computes the colon ideal (I:1*O) (as an O-ideal)}
    require Order(I) eq O : "the ideals must be of the same order";
    return I; //since we require O=Order(I)
end intrinsic;

intrinsic Inverse(I::AlgEtOrdIdl) ->AlgEtOrdIdl
{computes the inverse of an ideal of a maximal order}
    O:=Order(I);
    require IsMaximal(O): "only for ideals in maximal orders. use ColonIdeal otherwise";
    return ColonIdeal(O,I);
end intrinsic;

//----------
//
// Weak Equiv testing
//
//----------

intrinsic IsWeakEquivalent(I::AlgEtOrdIdl,J::AlgEtOrdIdl)->BoolElt
{ checks if 1 \in (I:J)*(J:I). This function does not require that the ideals are defined over the same order. }
    S := MultiplicatorRing(I);
    if MultiplicatorRing(J) ne S then
        return false;
    else
        IS:=S!!I;
        JS:=S!!J;
        CIJ:=ColonIdeal(IS,JS);
        CJI:=ColonIdeal(JS,IS);
        //test := OneIdeal(S) eq (CIJ*CJI); //note that this test does not depend on the order of definition of the ideals.
        id:=(CIJ*CJI);
        test:=One(Algebra(I)) in id; //faster!
        return test;
    end if;
end intrinsic;

intrinsic IsWeakEquivalent(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{ check if the two orders are weakly equivalent, that is equal }
    return O1 eq O2;
end intrinsic;

intrinsic IsWeakEquivalent(O::AlgEtOrd,J::AlgEtOrdIdl)->BoolElt
{ checks if the second argument is weakly equivalent to the first argument }
    return IsWeakEquivalent(OneIdeal(O), J);
end intrinsic;

intrinsic IsWeakEquivalent(J::AlgEtOrdIdl,O::AlgEtOrd)->BoolElt
{ checks if the second argument is weakly equivalent to the first argument }
    return IsWeakEquivalent(OneIdeal(O), J);
end intrinsic;

intrinsic IsInvertible(I::AlgEtOrdIdl) ->AlgEtOrdIdl
{ checks if the ideal is invertible in its order of definition }
    O:=Order(I);
    return IsWeakEquivalent(I,O);
end intrinsic;
*/

/* TEST

    Attach("~/packages_github/AlgEt/AlgEt.m");
    Attach("~/packages_github/AlgEt/AlgEtElt.m");
    Attach("~/packages_github/AlgEt/AlgEtOrd.m");
    Attach("~/packages_github/AlgEt/AlgEtTraceNorm.m");
    Attach("~/packages_github/AlgEt/AlgEtIdl.m");
    SetVerbose("AlgEtIdl",2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    for i in [1..100] do
        a:=Random(A);
        assert 1 eq #{Ideal(E1,a),a*E1,E1*a};
        assert 1 eq #{Ideal(E2,a),a*E2,E2*a};
        assert a*E2 eq E2!!(a*E1);
        assert E1!!(E2!!(a*E1)) ne a*E1;
    end for;

    K:=NumberField(x^2-5);
    _<y>:=PolynomialRing(K);
    E1:=NumberField(y^2-49*7*K.1);
    E2:=NumberField(y^5-25*7*K.1);
    A:=EtaleAlgebra([E1,E2]); 
    assert HasBaseField(A);
    time O:=MaximalOrder(A);
    for i in [1..100] do
        a:=Random(O);
        b:=Random(O);
        I:=Ideal(O,a);
        I:=a*O;
        I:=O*a;
    end for;

//to modify from here on    
    A:=EtaleAlgebra([K,K]);
    for i in [1..100] do
        a:=Random(A);
        b:=Random(A);
        assert Trace(a)+Trace(b) eq Trace(a+b);
        assert Norm(a)*Norm(b) eq Norm(a*b);
    end for;


    seq:=[NumberField(p),NumberField(x^2-5)];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));
    for O in [O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;

    K:=NumberField(x^2-25*5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    E:=NumberField(p); //relative ext
    A:=EtaleAlgebra([E,E]);
    O:=MaximalOrder(A);
    for i in [1..100] do
        a:=Random(O);
        b:=Random(O);
        assert AbsoluteTrace(a)+AbsoluteTrace(b) eq AbsoluteTrace(a+b);
        assert Trace(a)+Trace(b) eq Trace(a+b);
        assert AbsoluteNorm(a)*AbsoluteNorm(b) eq AbsoluteNorm(a*b);
        assert Norm(a)*Norm(b) eq Norm(a*b);
    end for;
*/


/*OLD TEST

//problem with CRT

AttachSpec("packages.spec");
  _<x>:=PolynomialRing(Integers());
f:=x^4+11*x^3+73*x^2+319*x+841;
A:=EtaleAlgebra(f);
q:=Integers() ! (Coefficients(f)[1]^(2/Degree(f)));
F:=PrimitiveElement(A);
V:=q*F^-1;
E:=Order([V,F]);
seqOO:=FindOverOrders(E);
[#PicardGroup(S) : S in seqOO];


*/
