/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Functions for order in Etale Q algebras
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtOrd, 1;

/*TODO:
- one should try to avoid constructing the AssOrder.
- modify ZBasis : don't use AssIdeal and add the Hash
- in MaximalOrder use the product of number fields instead of the AssAlg
- check that the attributes are all ok and needed
*/


declare type AlgEtOrd;

declare attributes AlgEt:MaximalOrder;

declare attributes AlgEtOrd : OneIdeal,
                              IsMaximal,
                              Index,
                              ZBasis,
                              Generators,
                              Algebra,
                              Conductor,
                              Hash;

//----------
// Basics
//----------

intrinsic Print(A::AlgEtOrd)
{Print the order.}
  printf"Order in Etale Algebra given by %o", A`Algebra;
end intrinsic;

intrinsic IsCoercible(S::AlgEtOrd, x::.) -> BoolElt, Any
{Return whether x is coercible into S and the result if so.}
    bool,x:=IsCoercible(Algebra(S),x);
    if bool and x in S then
        return true,x;
    else
        return false,_;
    end if;
end intrinsic;

//----------
// Auxiliary functions
//----------

crZQ:=function(M)
//given a matrix M over the Integers() changes the base ring to Rationals()
    return ChangeRing(M,Rationals());
end function;

crQZ:=function(M)
//given a matrix M over the Rationals() changes the base ring to Integers()
    return ChangeRing(M,Integers());
end function;

Columns:=function(M)
    return Rows(Transpose(M));
end function;

hnf:=function(M)
//input: a matrix over the Integers() 
//output: the matrix in HNF
    N:=Rank(M);
    H:=HermiteForm(M);
    H:=Matrix(Rows(H)[1..N]);
    return H;
end function;

MatrixAtoQ:=function(gens)
//input:  a sequence of elements of an AlgEt A
//output: a matrix over Rationals() whose coordinates are the AbsoluteCoordinates of gens
    return Matrix([AbsoluteCoordinates(g) : g in gens]);
end function;

MatrixAtoZ:=function(gens)
//return a matrix with integers entries which rows the elements of gens
    return crQZ(MatrixAtoQ(gens));
end function;

MatrixQToA:=function(A,P)
//given a matrix with Integer or Rational entries, returns a sequence of elements of A, corresponding to the rows.
    abs:=AbsoluteBasis(A);
    abs_dim:=AbsoluteDimension(A);
    assert #Columns(P) eq abs_dim;
    return [ &+[Eltseq(r)[i]*abs[i] : i in [1..abs_dim]] : r in Rows(P)];
end function;

//----------
// Creation
//----------

intrinsic Order( gens::SeqEnum[AlgEtElt] : Check:=100 ) -> AlgEtOrd
{Construnct the order generated by gens over the rationals. The parameter Check (default 100) determines how many times the program tries to obtain a multiplicatively closed lattice by adding the product of the generators. If Check 0 then this step is skipped.}
    A:=Universe(gens);
    gens:=Setseq(Seqset(gens));// we remove duplicates
    dim:=AbsoluteDimension(A);
    R:=New(AlgEtOrd);
    R`Algebra:=A;
    require forall{g : g in gens | IsIntegral(g) } : "The elements are not all integral, hence do not generate an order.";
    if Check gt 0 then 
        gens0:=gens;
        if not One(A) in gens then
            gens0:=[One(A)] cat gens0;
        end if;
        M:=MatrixAtoQ(gens0);
        d:=Integers()!Denominator(M);
        P:=hnf(crQZ(d*M));
        gens0:=MatrixQToA(A,P);
        fail:=0;
        repeat
            P_old:=P;
            gens0 cat:= [(g1*g2)/d : g1,g2 in gens0];
            M:=MatrixAtoZ(gens0);
            P:=hnf(M);
            gens0:=MatrixQToA(A,P);
            fail +:=1;
            go:=Rank(P_old) eq dim and P eq P_old;
        until go or fail gt Check;
        if fail gt Check then 
            error "The program could not generate a multiplicatively closed set from the given generators. Try to increase the value of Check, or choose different generators.";
        end if;

        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        // we compute the Hash
        R`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        zb:=MatrixQToA(A,P);
    else
    //we assume that gens is a ZBasis of a multiplicativly closed lattice
        zb:=gens;
    end if;

  assert #zb eq dim;
  if #gens le dim then
    R`Generators:=gens;
  else
    R`Generators:=zb;
  end if;
  R`ZBasis:=zb;
  assert2 One(A) in R;
  return R;
end intrinsic;


intrinsic OrderOver( gens::SeqEnum[AlgEtElt] , S::RngOrd : Check:=100 ) -> AlgEtOrd
{Given elements gens from an etale algebra A over a base field F and an order S in F, returns the order in A generated by gens over S. The parameter Check (default <true,100>) determines whether the programs checks if gens create a multiplicatively closed lattice, and if not adds elements until it is so, for Check[2] times.}
    A:=Universe(gens);
    F,mFA:=BaseField(A);
    require NumberField(S) eq F : "The base order does not lie in the bse field.";
    bOFinA:=[ mFA(b) : b in Basis(S)];
    gens:=[ g * b : g in gens, b in bOFinA ];
    return Order( gens : Check:=Check );
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(S::AlgEtOrd) -> AlgEt
{Returns the algebra of the order.}
  return S`Algebra;
end intrinsic;

intrinsic Hash(S::AlgEtOrd)->SeqEnum[RngInt]
{hash function for AlgEtOrd}
// two orders have the hash iff they are equal
    if not assigned S`Hash then
        N:=Dimension(Algebra(S));
        P:=MatrixAtoQ(ZBasis(S));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*hnf(crQZ(d*P));
        d:=Integers() ! Denominator(P);
        assert2 IsUpperTriangular(P);
        S`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..N] , i in [1..N]];
    end if;
    return S`Hash;
end intrinsic;

intrinsic ZBasis(S::AlgEtOrd)->SeqEnum[AlgEtElt]
{Return a Z-basis of the order.}    
    // assigned at creation
    return S`ZBasis;
end intrinsic;

intrinsic Generators(S::AlgEtOrd)->SeqEnum[AlgEtElt]
{Return a set of generators of the order.}    
    // assigned at creation
    return S`Generators;
end intrinsic;

//----------
// Equality
//----------

intrinsic 'eq'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same etale algebra";
    if O1`Generators eq O2`Generators or O1`ZBasis eq O2`ZBasis or Hash(O1) eq Hash(O2) then 
        out:=true;
    else
        out:=false;
    end if;
    vprintf AlgEtOrd,2 : "output of equality = ",out;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtOrd) do
            if assigned O1``att and not assigned O2``att then
                O2``att:=O1``att;
            elif assigned O2``att and not assigned O1``att then
                O1``att:=O2``att;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

/* CONTINUE from HERE

intrinsic IsMaximal(S::AlgEtOrd) -> BoolElt
{}
end intrinsic;

//----------
// Inclusion
//----------

intrinsic 'in'(x::AlgEtElt,O::AlgEtOrd) -> BoolElt
{inclusion of elements} 
    require Algebra(x) cmpeq Algebra(O) : "the algebra is not the same";
    if (assigned O`Generators and x in O`Generators)
        or (assigned O`ZBasis and x in O`ZBasis) then
        return true;
    end if;
    mat := Coordinates([x], ZBasis(O))[1];
    return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

//----------
//
// Index
//
//----------

intrinsic Index(T::AlgEtOrd) -> FldRatElt
{given an order T computes its index with respect to the basis of the algebra of T as a free Z-module}
  if not assigned T`Index then
    matT:=Matrix(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(S::AlgEtOrd, T::AlgEtOrd) -> Any
{given two orders T \subset S, returns [S:T] = #S/T }
  assert Algebra(T) cmpeq Algebra(S);
  elt := Index(T)/Index(S);
  if IsCoercible(Integers(), elt) then
    elt := Integers() ! elt;
  end if;
  return elt;
end intrinsic;

//----------
//
// Basic functions
//
//----------

intrinsic One(S::AlgEtOrd)->AlgEtElt
{unit element of S}
    A:=Algebra(S);
    return One(A);
end intrinsic;

intrinsic Zero(S::AlgEtOrd)->AlgEtElt
{zero element of S}
    A:=Algebra(S);
    return Zero(A);
end intrinsic;

intrinsic OneIdeal(S::AlgEtOrd) -> AlgEtOrdIdl
{given an S returns the ideal 1*S which will be cached}
  if not assigned S`OneIdeal then
    S`OneIdeal := Ideal(S,One(S));
  end if;
  return S`OneIdeal;
end intrinsic;

intrinsic MultiplicatorRing(R::AlgEtOrd) -> AlgEtOrd
{returns the MultiplicatorRing of an order R, that is R itself}
    return R;
end intrinsic;

intrinsic ListToSequence(L::List)->SeqEnum
{given a list of elements returns the same sequence}
    return [s : s in L];
end intrinsic;

intrinsic Discriminant(R::AlgEtOrd) -> RngInt
{returns the discriminant of the order}
    return Discriminant(AssOrder(R));
end intrinsic;

intrinsic Random(O::AlgEtOrd : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtElt
{ Returns a random (small coefficient) element of O. 
  The range of the random coefficients can be increased by giving the optional argument CoeffRange.
  One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
    B := ZBasis(O);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-CoeffRange..CoeffRange])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-CoeffRange..CoeffRange])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

//----------
//
// Binary operation
//
//----------

intrinsic 'subset'(O1 :: AlgEtOrd, O2 :: AlgEtOrd) -> BoolElt
{Checks if the first argument is inside the second.}
  require Algebra(O1) cmpeq Algebra(O2) : "The orders must be in the same algebra.";
  if not Index(O2, O1) in Integers() then
    return false;
  end if;
  mat := Matrix(Coordinates(Generators(O1), ZBasis(O2)));
  return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

intrinsic 'meet'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O2;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O1;
    end if;
    if O1 subset O2 then
        return O1;
    end if;
    if O2 subset O1 then
        return O2;
    end if;
    return Order(Algebra(O1),AssociativeOrder(O1) meet AssociativeOrder(O2));
end intrinsic;

intrinsic '*'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if O1 eq O2 then
        return O1;
    end if;
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O1;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O2;
    end if;
    if O1 subset O2 then
        return O2;
    end if;
    if O2 subset O1 then
        return O1;
    end if;
    gens:=Setseq( Seqset(Generators(O1) cat Generators(O2)) );
    return Order(gens);
end intrinsic;

//----------
//
// Maximal Order
//
//----------

intrinsic IsMaximal(O::AlgEtOrd) -> BoolElt
{ checks if the order is the maximal order of its associative algebra}
    if not assigned O`IsMaximal then
        OK:=MaximalOrder(Algebra(O));
        O`IsMaximal:=OK eq O;
    end if;
    return O`IsMaximal;
end intrinsic;

intrinsic MaximalOrder(A::AlgEt)->AlgEtOrd
{return the maximal order of an etale algebra}
    if not assigned A`MaximalOrder then
        Ass:=AssAlgebra(A);
        O:=MaximalOrder(Ass);
        R:=Order([A!z : z in ZBasis(O)] : Check:=false );
        R`IsMaximal:=true;
        A`MaximalOrder:=R;
    end if;
    return A`MaximalOrder;
end intrinsic;

intrinsic MaximalOrder(O::AlgEtOrd)->AlgEtOrd
{return the maximal order of an etale algebra}
    bool:=IsMaximal(O);//this triggers the computation of the maximal order and assignes O`IsMaximal
    return MaximalOrder(Algebra(O));
end intrinsic;

//----------
//
// Others
//
//----------

intrinsic ProdEqOrders(A::AlgEt)->AlgEtOrd
{given a product of number fields A, returns the order consisting of the product of the equation orders of the number fields}
    gen_inA:=[];
    for L in A`NumberFields do
        EL:=EquationOrder(L[1]);
        gen_inA:=gen_inA cat [L[2](y) : y in Basis(EL,L[1])];
    end for;
    return Order(gen_inA);
end intrinsic;

intrinsic IsBass(S::AlgEtOrd) -> BoolElt
{check if the order is Bass}
// we compute the maximal order O and check if O/PO is at most 2-dimensional over S/P for every singular prime P
// This coincides with the usual definition since O has the maximal number of generators as a fractional S ideal and S is Bass iff every ideal can be generated by at most 2-elements.
// see Hofman,Sircana, On the computations of over-orders, Definition 5.23
    if IsMaximal(S) then 
        return true;
    else
        O:=MaximalOrder(Algebra(S));
        ff:=Conductor(S);
        sing:=PrimesAbove(ff);
        for P in sing do
            k:=Integers() ! Index(S,P);
            OS:=Ideal(S,ZBasis(O));
            N:=Integers() ! Index(OS,P*OS);
            //N = k^(dim_P)
            assert N mod k eq 0;
            dim_P:=Ilog(k,N);
            if dim_P gt 2 then
                return false; //S is not Bass at P
            end if;
        end for;
        return true;
    end if;
end intrinsic;

intrinsic EquationOrder(A::AlgEt) -> AlgEtOrd
{given an associative algebra defined by a polynomial, returns the monogenic order defined by the same polynomial}
    F:=PrimitiveElement(A);
    E:=Order([F]);
    return E;
end intrinsic;

intrinsic Conductor(O::AlgEtOrd) ->AlgEtOrdIdl
{computes the conductor of an order}
    if not assigned O`Conductor then
        A:=Algebra(O);
        OA:=MaximalOrder(A);
        O`Conductor:=ColonIdeal(O,Ideal(O,ZBasis(OA)));
    end if;
    return O`Conductor;
end intrinsic;

intrinsic IsGorenstein(O::AlgEtOrd)->BoolElt
{ checks if the order O is Gorenstein }
    T:=TraceDualIdeal(O);
    return IsInvertible(T);
end intrinsic

intrinsic IsProductOfOrders(O::AlgEtOrd)->BoolElt, Tup
{return if the argument is a product of orders in number fields, and if so return also the sequence of these orders}
    A:=Algebra(O);
    idem:=OrthogonalIdempotents(A);
    test:=forall{x : x in idem | x in O};
    O_asProd:=<>;
    is_max:=IsMaximal(O);
    if test then
        for i in [1..#A`NumberFields] do
            L:=A`NumberFields[i];
            gen_L:=[(x*idem[i])@@L[2]: x in Generators(O)];
            O_L:=Order(gen_L);
            if is_max then
                if not assigned O_L`Maximal then O_L`Maximal:=true;
                else assert O_L`Maximal eq true;
                end if;
                if not assigned L[1]`MaximalOrder then L[1]`MaximalOrder:=O_L;
                else assert2 L[1]`MaximalOrder eq O_L;
                end if;
                //note: is not is_max it might still happen than OL is the maximal order of L. that's why we don't set it
            end if;
            Append(~O_asProd,O_L);
        end for;
        return true, O_asProd;
    else
        return false,<>;
    end if;
end intrinsic;

*/

/* TEST TO MODIFy

    SetVerbose(AlgEtOrd,2);

    Attach("~/packages_github/AlgEt/AlgEt.m");
    Attach("~/packages_github/AlgEt/AlgEtElt.m");
    Attach("~/packages_github/AlgEt/AlgEtOrd.m");
    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    time O1:=Order(Basis(A));
    Hash(O1);
    ZBasis(O1);
    Generators(O1);
    time O2:=Order(AbsoluteBasis(A) : Check:=0);
    Hash(O2);
    time O3:=Order(AbsoluteBasis(A));
    Hash(O3);
    time O1 eq O2;
    time O2 eq O3;


    seq:=[x^2-5,x^2-7];
    seq:=[NumberField(f) : f in seq];
    A:=EtaleAlgebra(seq);
    time O1:=Order(Basis(A));
    time O2:=Order(AbsoluteBasis(A));
    time O1 eq O2;

    K:=NumberField(x^2-5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    A:=EtaleAlgebra(p);
    time O1:=Order(Basis(A)); //this should trigger an error
    time O2:=Order(AbsoluteBasis(A));
    
    A:=EtaleAlgebra([K,K]);
    time O1:=Order(Basis(A));
    time O2:=Order(AbsoluteBasis(A));
    time O1 eq O2;

    seq:=[NumberField(p),NumberField(x^2-5)];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));

    K:=NumberField(x^2-25*5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    E:=NumberField(p); //relative ext
    seq:=[E,E];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));
    F,m:=BaseField(A);
    assert F eq K;
    time O1:=Order(Basis(A));//this should trigger an error
    time O3:=OrderOver(Basis(A),EquationOrder(F));
    time O4:=OrderOver(Basis(A),MaximalOrder(F));
    time O3 eq O4;
    time O3 eq O2;
    time O4 eq O2;

*/


/*OLD TEST

Attach("et_algebras.m");
Attach("et_orders.m");
Attach("et_ideals.m");
_<x>:=PolynomialRing(Integers());
f:=(x^8+16)*(x^8+81);
A:=EtaleAlgebra(f);
O:=EquationOrder(A);
ZBasis(O);
ZBasis(O)[1] in O;
One(O);
OneIdeal(O);








*/
