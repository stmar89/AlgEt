/* vim: set syntax=magma :*/

/////////////////////////////////////////////////////
// Stefano Marseglia, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
// 
// Distributed under the terms of the GNU Lesser General Public License (L-GPL)
//      http://www.gnu.org/licenses/
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 3.0 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
// 
// Copyright 2023, S. Marseglia
/////////////////////////////////////////////////////

freeze;

declare verbose AlgEtQIdl, 3;

declare type AlgEtQIdl;
declare attributes AlgEtQIdl : Index, //stores the index
                              Order, //order of definition. it might be smaller than the multiplicator ring
                              Algebra,
                              MultiplicatorRing,
                              Generators,
                              ZBasis,
                              KnownPowers, //an associative array storing the known powers of an ideal
                              IsPrime,
                              IsInvertible,
                              Inverse,
                              IsIntegral,
                              MinimalInteger,
                              PrimesAbove,
                              Factorization,
                              IsProductOfIdeals,
                              TraceDualIdeal,
                              Hash,
                              inclusion_matrix;

import "Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;

//----------
// Creation functions
//----------

CreateAlgEtQIdl:=function(S,gens)
// Given S::AlgEtQOrd and some generators creates the new object 
// The ZBasis is computed only if there are more generators than the dimension of the algebra.
    A:=Algebra(S);
    I:=New(AlgEtQIdl);
    I`Algebra:=A;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(A) then
        ZZ:=Integers();
        vprint AlgEtQIdl,3: "CreateAlgEtQIdl: too many gens";
        gens:=[g*s : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(A);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(A,P);
        assert #zb eq AbsoluteDimension(A);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    if (assigned S`IsMaximal and IsMaximal(S)) or #gens eq 1 then
        I`IsInvertible:=true;
        I`MultiplicatorRing:=S; 
    end if;
    I`KnownPowers:=AssociativeArray();
    return I;
end function;

intrinsic Ideal(S::AlgEtQOrd, gens::SeqEnum) -> AlgEtQIdl
{Creates an ideal of S, generated by gens.}
    A:=Algebra(S);
    gensA:=[];
    for g in gens do
        bool,gA:=IsCoercible(A,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensA,gA);
    end for;
    return CreateAlgEtQIdl(S,gensA);
end intrinsic;

intrinsic Ideal(S::AlgEtQOrd, idls::Tup) -> AlgEtQIdl
{Given an order S which is a product of orders S_i in the number fields generating the Algebra(S), and a Tup of ideals I_i of S_i, returns the S-ideal corresponding to the direct sum of the I_i.}
    A:=Algebra(S);
    test,SasProd:=IsProductOfOrders(S);
    require test : "The order needs to be a product.";
    require #SasProd eq #idls : "The sequence does not contain enough ideals to generate a lattice in Algebra(S).";
    require forall{ i : i in [1..#idls] | Order(idls[i]) eq SasProd[i]} : "The ideals are not defined over the components of S.";
    A:=Algebra(S);
    _,embs:=Components(A);
    gens:=&cat[ [embs[i](g) : g in Generators(idls[i])] : i in [1..#idls] ];
    I:=Ideal(S,gens);
    I`IsProductOfIdeals:=<true,idls>;
    return I;
end intrinsic;

intrinsic Ideal(S::AlgEtQOrd, gen::Any) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    id:=Ideal(S,[gen]);
    id`MultiplicatorRing:=S;
    return id;
end intrinsic;

intrinsic '*'(S::AlgEtQOrd, gen::AlgEtQElt) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::AlgEtQElt, S::AlgEtQOrd) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtQOrd, gen::RngIntElt) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::RngIntElt, S::AlgEtQOrd) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtQOrd, gen::FldRatElt) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::FldRatElt, S::AlgEtQOrd) -> AlgEtQIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic Print(I::AlgEtQIdl)
{Prints the ideal.}
  printf"Ideal of %o", Order(I);
end intrinsic;

//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtQOrd,I::AlgEtQIdl) -> AlgEtQIdl
{Given an S-ideal I and an order T, returns the extension IT as a T-ideal. Note that if T is a subset of S, then IT=I.}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        id:=Ideal(T,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=I`MultiplicatorRing; //..as well as the MultiplicatorRing
        end if;
        return id;
    else //in this case Order(I) is strictly contained in T
        out:=Ideal(T,Generators(I));
        if (assigned T`IsMaximal and IsMaximal(T)) or (assigned I`IsInvertible and IsInvertible(I)) then
            out`IsInvertible:=true;
            out`MultiplicatorRing:=T;
        end if;
        return out;
    end if;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(I::AlgEtQIdl) -> AlgEtQ
{Returns the Ã©tale algebra in which the ideal lives.}
    return I`Algebra;
end intrinsic;

intrinsic Order(I::AlgEtQIdl) -> AlgEtQOrd
{Returns the order of definition of the ideal.}
    return I`Order;
end intrinsic;

intrinsic ZBasis(I::AlgEtQIdl)->SeqEnum[AlgEtQElt]
{Returns a Z-basis of the ideal.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        A:=Algebra(I);
        S:=Order(I);
        gens:=[g*s : g in Generators(I) , s in ZBasis(S) ];
        if #Generators(I) eq 1 then
            zb:=gens; //gens is a ZBasis of I
        else
            dim:=AbsoluteDimension(A);
            M:=MatrixAtoQ(gens);
            d:=Integers()!Denominator(M);
            P:=hnf(crQZ(d*M));
            P:=(1/d)*crZQ(P);
            d:=Denominator(P); //this d might be different from Denomintor(M)
            hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
            // UNSAFE hash:=Hash(P);
            zb:=MatrixQtoA(A,P);
            assert #zb eq AbsoluteDimension(A);
            I`Hash:=hash;
        end if;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic Generators(I::AlgEtQIdl) -> SeqEnum[AlgEtQElt]
{Returns the generators of the ideal.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(Algebra(I));
    return I`Generators;
end intrinsic;

intrinsic myHash(I::AlgEtQIdl)->RngInt
{Hash function.}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(Algebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Inclusion and equality
//----------

intrinsic 'eq'(I::AlgEtQIdl , J::AlgEtQIdl ) -> BoolElt
{Equality testing.}
    require Algebra(I) cmpeq Algebra(J) : "The ideals are not in the same algebra.";
    require Order(I) cmpeq Order(J) : "The ideals are not over the same order.";
    if  (not (assigned I`Hash and assigned J`Hash)) and
        (assigned I`Generators and assigned J`Generators and Generators(I) eq Generators(J)) then
        // to compute myHash we need compute an HNF. In this way we might avoid it.
        out:=true;
        //note that the set of generators is not unique for an ideal.
    else
        out:=myHash(I) eq myHash(J);
    end if;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtQIdl) do
            if att ne "inclusion_matrix" then // we exclude the attributes that depend on the ZBasis
                if assigned I``att and not assigned J``att then
                    J``att:=I``att;
                elif assigned J``att and not assigned I``att then
                    I``att:=J``att;
                end if;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtQIdl , J::AlgEtQIdl ) -> BoolElt
{Equality testing.}
    return not I eq J;
end intrinsic;

intrinsic 'eq'(I::AlgEtQIdl, S::AlgEtQOrd) -> BoolElt
{Return if I eq S. I needs to be an ideal of S.}
  assert Algebra(I) cmpeq Algebra(S);
  if Index(S, I) eq 1 then
      return I eq OneIdeal(S);
  else
      return false;
  end if;
end intrinsic;

intrinsic 'eq'(S::AlgEtQOrd,I::AlgEtQIdl) -> BoolElt
{Return if I eq S. I needs to be an ideal of S.}
    return I eq S;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtQElt],I::AlgEtQIdl) -> SeqEnum
{AbsoluteCoordiantes with respect to the ZBasis.} 
    require forall{x : x in seq | Algebra(x) cmpeq Algebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtQElt , I::AlgEtQIdl ) -> BoolElt
{Returns if x is in I.}
    require Algebra(x) eq Algebra(I) : "the elements must lie in the same algebra of definition";
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt , I::AlgEtQIdl ) -> BoolElt
{Returns if x is in I.}
    return (Algebra(I)!x) in I;
end intrinsic;

intrinsic 'in'(x::FldRatElt , I::AlgEtQIdl ) -> BoolElt
{Returns if x is in I.}
    return (Algebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(S::AlgEtQOrd,I::AlgEtQIdl) -> BoolElt
{Given an ideal I of S, return if S subseteq I.}
    require Order(I) eq S: "the second argument must be an ideal of the first argument";
    return OneIdeal(S) subset I;
end intrinsic;

intrinsic 'subset'(I::AlgEtQIdl,S::AlgEtQOrd) -> BoolElt
{Given an ideal I of S, return if I subseteq S.}
    require Order(I) eq S: "the first argument must be an ideal of the second argument";
    return I subset OneIdeal(S);
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtQIdl, I2 :: AlgEtQIdl) -> BoolElt
{Checks if the first argument is inside the second. The ideals need to be fractional.}
  require Order(I1) eq Order(I2) : "The ideals must be in the same order.";
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtQIdl) -> FldRatElt
{Given an ideal T computes its index with respect to the basis of the algebra of T as a free Q-module.}
  if not assigned T`Index then
    matT := MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtQIdl, I::AlgEtQIdl) -> Any
{Given fractional ideals J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].}
  require Order(I) eq Order(J): "the ideals must be of the same order";
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;

intrinsic Index(S::AlgEtQOrd, I::AlgEtQIdl) -> Any
{Given and ideal I of an order S returns [S:I] = [S:S cap I]/[I : S cap I].}
    require Order(I) eq S: "the ideal must be of the appropriate order";
    return Index(OneIdeal(S), I);
end intrinsic;


//----------
// Special ideals
//----------

intrinsic OneIdeal(S::AlgEtQOrd) -> AlgEtQIdl
{Given an order S returns the ideal 1*S which will be cached.}
  if not assigned S`OneIdeal then
    S`OneIdeal := Ideal(S,One(S));
    S`OneIdeal`IsInvertible:=true;
    S`OneIdeal`MultiplicatorRing:=S;
  end if;
  return S`OneIdeal;
end intrinsic;

intrinsic Conductor(O::AlgEtQOrd) ->AlgEtQOrdIdl
{Computes the conductor of an order, defined as he colon ideal (O:OK), where OK is the maximal order of the algebra.}
    if not assigned O`Conductor then
        A:=Algebra(O);
        OA:=MaximalOrder(A);
        cc:=ColonIdeal(O,O!!OneIdeal(OA));
        ZBasisLLL(cc);
        O`Conductor:=cc;
    end if;
    return O`Conductor;
end intrinsic;

//----------
// Binary operations
//----------

intrinsic '+'(I::AlgEtQIdl , J::AlgEtQIdl ) -> AlgEtQIdl
{Returns the sum of two ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    if I eq J then
        return I;
    elif I subset J then
        return J;
    elif J subset I then
        return I;
    end if;
    S:=Order(I);
    gens:=Generators(I) cat Generators(J);
    return Ideal(S,gens);
end intrinsic;

intrinsic '*'(I::AlgEtQIdl , J::AlgEtQIdl ) -> AlgEtQIdl
{Product of two ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    S:=Order(I);
    if I eq OneIdeal(S) then
        return J;
    elif J eq OneIdeal(S) then
        return I;
    end if;
    gI:=Generators(I);
    gJ:=Generators(J);
    if #gI eq 1 then //better for passing the attributes
        return J*gI[1];
    elif #gJ eq 1 then
        return I*gJ[1];
    else
        gens:=[i*j : i in gI, j in gJ ];
        out:=Ideal(S,gens);
        if assigned I`IsInvertible and assigned J`IsInvertible then
            out`IsInvertible:=IsInvertible(I) and IsInvertible(J);
        end if;
        return out;
    end if;
end intrinsic;

intrinsic '*'(I::AlgEtQIdl , x::AlgEtQElt ) -> AlgEtQIdl
{Returns x*I.}
    bool,x:=IsCoercible(Algebra(I),x);
    if not bool then
        error "the element must be in the same algebra of I";
    else
        S:=Order(I);
        gens:=[i*x : i in Generators(I) ];
        id:=Ideal(S,gens);
        if assigned I`ZBasis and not assigned id`ZBasis then
            id`ZBasis:=[x*z : z in ZBasis(I)];
        end if;
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`IsInvertible then
            id`IsInvertible:=IsInvertible(I);
        end if;
        return id;
    end if;
end intrinsic;

intrinsic '*'(x::AlgEtQElt, I::AlgEtQIdl) -> AlgEtQIdl
{Returns x*I.}
    return I*x;
end intrinsic;

intrinsic '*'(x::RngIntElt, I::AlgEtQIdl) -> AlgEtQIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtQIdl, x::RngIntElt) -> AlgEtQIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(x::FldRatElt, I::AlgEtQIdl) -> AlgEtQIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtQIdl, x::FldRatElt) -> AlgEtQIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '^'(I::AlgEtQIdl, n::RngIntElt) -> AlgEtQIdl
{nth power of an ideal.}
    S:=Order(I);
    power_invertible:=function(I,n)
    // given an invertible ideal I and positive integer n return I^n

    // Lemma:
    // Let I be an invertible fractional S-ideal generated globally by I=aS+bS.
    // For every integer N, we have I^N=a^NS+b^NS.
    // Proof: we will show it locally at every prime. Since I is invertible, then it is locally principal.
    // Pick a prime P. Then by Nakayama's Lemma I_P=(a/1)S_P or I_P=(b/1)S_P. wlog assume the first. Then I_P^N=(a^N/1)S_P. QED.
    //
    // Remark: this trick does not work for product of invertible ideals I and J. 
    // One can have I_P1=(a) J_P1=(c) but I_P2=(a), J_P2=(d) so one cannot avoid the mixed products.
        TwoGeneratingSet(I);
        gg:=Generators(I);
        assert #gg le 2;
        out:=Ideal(Order(I),[g^n : g in gg]);
        out`IsInvertible:=true;
        if assigned I`MultiplicatorRing then 
            out`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`PrimesAbove then
            out`PrimesAbove:=PrimesAbove(I);
        end if;
        if assigned I`Factorization then
            out`Factorization:=< <fac[1],n*fac[2]> : fac in Factorization(I) >;
        end if;
        return out;
    end function;
    power_positive:=function(I, n)
        id := I;
        n0:=0;
        output := OneIdeal(S);
        bin_exp:=IntegerToSequence(n,2);
        for i in [1..#bin_exp] do
            if bin_exp[i] eq 1 then
                n0 +:=2^(i-1);
                is_def,In0:=IsDefined(I`KnownPowers,n0);
                if is_def then 
                    output := In0;
                else
                    output *:= id;
                    I`KnownPowers[n0]:=output;
                end if;
            end if;
            if i lt #bin_exp then
                ni:=2^i;
                is_def,Ini:=IsDefined(I`KnownPowers,ni);
                if is_def then 
                    id:=Ini;
                else
                    id := id*id; // I^(2^i)
                    I`KnownPowers[ni]:=id;
                end if;
            end if;
        end for;
        return output;
    end function;
    if not IsDefined(I`KnownPowers,n) then 
        if n eq 0 then
            output:=OneIdeal(S);
        elif n eq 1 then
            output:=I;
        else
            if n gt 0 then
                if assigned I`IsInvertible and IsInvertible(I) then
                    output:=power_invertible(I,n);
                else
                    output:=power_positive(I,n);
                end if;
            end if;
            if n lt 0 then
                invI:=Inverse(I);
                if n eq -1 then
                    output:=invI;
                else
                    output:=power_invertible(invI,-n);
                end if;
            end if;
        end if;
        I`KnownPowers[n]:=output;
    end if;
    return I`KnownPowers[n];
end intrinsic;
 
intrinsic 'meet'(I::AlgEtQIdl, S::AlgEtQOrd) -> AlgEtQIdl
{Given an ideal I of S, return S cap I.}
    return S meet I;
end intrinsic;

intrinsic 'meet'(S::AlgEtQOrd,I::AlgEtQIdl) -> AlgEtQIdl
{Given an ideal I of S, return S cap I.}
    output := OneIdeal(S) meet I;
    return output;
end intrinsic;

intrinsic 'meet'(I::AlgEtQIdl, J::AlgEtQIdl) -> AlgEtQIdl
{Given ideals I and J, return J cap I.}
// this code is inspired by H.Cohen "Advanced Topics in ...", page 36.]
// note that the hnf in Magma is not the same as in the book. This is why the matrix M and P are take in a slightly different way compared to the refernce.
    require Order(I) eq Order(J): "the ideals must be defined over the same order";
    A:=Algebra(I);
    if I subset J then 
        return I;
    end if;
    if J subset I then
        return J;
    end if;
    zb:=meet_zbasis(ZBasis(I),ZBasis(J));
    id:=Ideal(Order(I),zb);
    id`ZBasis:=zb;
    return id;
end intrinsic;

//----------
// On Sequences
//----------

intrinsic '&+'(seq::SeqEnum[AlgEtQIdl])->AlgEtQIdl
{Returns the sum of the fractional ideals in the sequence.}
    id:=Ideal(Order(seq[1]),&cat[Generators(I):I in seq]);
    return id;
end intrinsic;

// an analogous definition of &* seems to be very slow, probably because the number of generators grows too fast.

//----------
// ColonIdeals
//----------

intrinsic ColonIdeal(I::AlgEtQIdl,J::AlgEtQIdl)->AlgEtQIdl
{Computes the colon ideal (I:J) (as an O-ideal) of two O-ideals, which is the set of elements x of the algebra such that x*J subset I.}
    A:=Algebra(I);
    O := Order(I);
    require Order(J) eq O : "the ideals must be of the same order";
    if assigned J`Generators and #J`Generators eq 1 then
        j:=J`Generators[1];
        out:=(1/j)*I;
        return out;
    end if;
    // based on jv code
    N:=AbsoluteDimension(A);
    zbI:=ZBasis(I);
    //mIinv:=MatrixAtoQ(zbI)^-1;
    mIinv:=inclusion_matrix(I);
    zbJ:=ZBasis(J);
    bas:=AbsoluteBasis(A);
    M:=VerticalJoin([ Transpose( MatrixAtoQ([zj*bas[i] : i in [1..N]])*mIinv) : zj in zbJ] );
    d:=Denominator(M);
    P:=(1/d)*crZQ(hnf(crQZ(d*M)));
    P:=Transpose(P)^-1;
    zbIJ:=MatrixQtoA(A,P);
    IJ:=Ideal(O,zbIJ);
    IJ`ZBasis:=zbIJ; //we know that zbIJ is a ZBasis
    assert2 IJ*J subset I;
    return IJ;
end intrinsic;

intrinsic ColonIdeal(O::AlgEtQOrd,J::AlgEtQIdl)->AlgEtQIdl
{Computes the colon ideal (1*O:J) (as an O-ideal).}
    require Order(J) eq O : "The ideal is not defined of the same order";
    return ColonIdeal(OneIdeal(O), J);
end intrinsic;

intrinsic ColonIdeal(I::AlgEtQIdl,O::AlgEtQOrd)->AlgEtQIdl
{Computes the colon ideal (I:1*O) (as an O-ideal).}
    require Order(I) eq O : "The ideal is not defined of the same order";
    return I; //since we require O=Order(I)
end intrinsic;

intrinsic IsInvertible(I::AlgEtQIdl) ->BoolElt
{Checks if the ideal I is invertible in its order of definition O.}
    if not assigned I`IsInvertible then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        test:=One(O) in I*COI;
        I`IsInvertible:=test;
        if test then
            I`Inverse:=COI;
            I`MultiplicatorRing:=O;
            COI`IsInvertible:=true;
            COI`MultiplicatorRing:=O;
            COI`Inverse:=I;
            I`Inverse:=COI;
        end if;
    end if;
    return I`IsInvertible;
end intrinsic;

intrinsic Inverse(I::AlgEtQIdl) ->AlgEtQIdl
{Computes the inverse of an invertible ideal.}
    require IsInvertible(I) : "The ideal is not invertible in the order of definition";
    if not assigned I`Inverse then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        COI`IsInvertible:=true;
        COI`MultiplicatorRing:=O;
        COI`Inverse:=I;
        I`Inverse:=COI;
    end if;
    return I`Inverse;
end intrinsic;

intrinsic MultiplicatorRing(I::AlgEtQIdl) -> AlgEtQOrd
{Given a fractional ideal I computes its multiplicator ring (I:I).}
    if not assigned I`MultiplicatorRing then
        R:=Order(I);
        if #Generators(I) eq 1 then
            I`MultiplicatorRing:=R;
        elif assigned R`IsMaximal and R`IsMaximal then
            I`MultiplicatorRing:=R;
        elif assigned I`IsInvertible and I`IsInvertible then
            I`MultiplicatorRing:=R;
        else 
            A:=Algebra(I);
            zbS:=ZBasis(ColonIdeal(I,I));
            S:=Order(zbS : Check:=0 );
            I`MultiplicatorRing:=S;
        end if;
    end if;
    return I`MultiplicatorRing;
end intrinsic;

//----------
// IsProductOfIdeals
//----------

intrinsic IsProductOfIdeals(I::AlgEtQIdl) -> BoolElt, Tup
{Return if the argument is a product of ideals in the number fields defining the algebra. If so, it returns also the sequence of these ideals (in the appropriate orders). Note: we require the Order(I) to be the MultiplicatorRing(I).}
    if not assigned I`IsProductOfIdeals then
        O:=Order(I);
        require O eq MultiplicatorRing(I) : "The ideal needs to be defined over its multiplicator ring.";
        A:=Algebra(O);
        test,orders:=IsProductOfOrders(O);
        if test then
            nf,_,projs:=Components(A); 
            zb:=ZBasis(I);
            ideals:=< ideal< orders[i] | [ projs[i](z) : z in zb ] > : i in [1..#orders] >;
            I`IsProductOfIdeals:=<true, ideals>;
        else
            I`IsProductOfIdeals:=<false,<>>;
        end if;
    end if;
    return Explode(I`IsProductOfIdeals);
end intrinsic;

//----------
// Random Elements
//----------

intrinsic Random(I::AlgEtQIdl , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Random element of I. The Coefficients are bounded by the positive integer bd. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false.}
    require bd gt 0 : "The bound needs to be a positive integer.";
    ZBasisLLL(I); // to keep it small
    B := ZBasis(I);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic Random(I::AlgEtQIdl : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random (small coefficient) element of I. The range of the random coefficients can be increased by giving the optional argument CoeffRange. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false.}
      return Random(I,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;

//----------
// Integral, Coprime, Minimal Integer and Coprime Representative
//----------

intrinsic IsCoprime(I::AlgEtQIdl,J::AlgEtQIdl) -> BoolElt
{Given two integral ideals I and J of an order S, returns whether I+J=R.}
    require Algebra(I) cmpeq Algebra(J) : "the ideals must lie in the same algebra";
    S:=Order(J);
    require Order(I) eq S: "the ideals must be over the same order";
    if I eq J then
        return false;
    end if;
    if assigned I`IsPrime and assigned J`IsPrime then
        if IsPrime(I) and IsPrime(J) then
            return true; //we already know that the ideals are distinct
        end if;
    end if;
    require IsIntegral(I) and IsIntegral(J): "the ideals must be integral";
    g:=GCD(MinimalInteger(I),MinimalInteger(J));
    if g eq 1 then
        return true;
    else
        return (One(S) in I+J); //here we generate a new ideal, which is expensive.
    end if;
end intrinsic;

intrinsic IsIntegral(I::AlgEtQIdl) -> BoolElt
{Returns wheter the ideal I of S is integral, that is I subseteq S.}
    if not assigned I`IsIntegral then
        S:=Order(I);
        I`IsIntegral:=I subset S;
    end if;
    return I`IsIntegral;
end intrinsic;

intrinsic MakeIntegral(I::AlgEtQIdl) -> AlgEtQIdl,RngIntElt
{Given a fractional S ideal I, returns the ideal d*I,d when d is the smallest integer such that d*I is integral in S. Compare with SmallRepresentative.}
    if IsIntegral(I) then return I,1; end if;
    S:=Order(I);
    d:=LCM(&cat[ [Denominator(x_coord) : x_coord in x] : x in AbsoluteCoordinates(Generators(I),S)]);
    dI:=d*I;
    assert2 dI subset S;
    return dI, d;
end intrinsic;

intrinsic MinimalInteger(I::AlgEtQIdl) -> RngIntElt
{Returns the smallest integer contained in the ideal I.}
    if not assigned I`MinimalInteger then
        require IsIntegral(I): "the ideal must be integral";
        ZZ:=Integers();
        coord:=AbsoluteCoordinates([One(Algebra(I))],I)[1];
        min:=LCM([ Denominator(c) : c in Eltseq(coord)]);
        assert2 min in I;
        I`MinimalInteger:=min;
    end if;
    return I`MinimalInteger;
end intrinsic;

intrinsic CoprimeRepresentative(I::AlgEtQIdl,J::AlgEtQIdl) -> AlgEtQElt,AlgEtQIdl
{Returns an element x such that x*I is an integral ideal coprime with J, togheter with the product x*I. The first ideal must be invertible and the second should be integral.}
    require IsIntegral(J) : "the second ideal must be integral";
    S:=Order(I);
    require S eq Order(J): "the ideals must be defined over the same order";
    x:=One(Algebra(I));
    xI:=I;
    while not (IsIntegral(xI) and IsCoprime(xI,J)) do
        x:=Random(Inverse(I)); //Inverse is cached
        xI:=x*I;
    end while;
    vprintf AlgEtQIdl,2: "CoprimeRepresentative:\n
                            I = %o\n,xI = %o\n",PrintSeqAlgEtQElt(ZBasis(I)),PrintSeqAlgEtQElt(ZBasis(xI));
    return x,xI;
end intrinsic;


/* TESTS

    printf "### Testing Ideals:";
    //AttachSpec("~/packages_github/AlgEt/spec");
    SetVerbose("AlgEtQIdl",1);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    for i in [1..100] do
        a:=Random(A);
        assert 1 eq #{Ideal(E1,a),a*E1,E1*a};
        assert 1 eq #{Ideal(E2,a),a*E2,E2*a};
        assert a*E2 eq E2!!(a*E1);
        assert E1!!(E2!!(a*E1)) ne a*E1;
        printf ".";
    end for;

    _:={ Random(E1)*E1 : i in [1..100] };
    _:=a*E1 + E1!!(a*E2);
    _:=&*[Random(E1)*E1 : i in [1..100]];
    _:=&*[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    l:=[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    assert forall{ I : I in l | not assigned I`ZBasis };
    assert forall{ I : I in l | I eq Ideal(E1,ZBasis(I))};
    assert forall{ I : I in l | assigned I`ZBasis };
    _:=&+[ i eq j select 1 else 0 : i,j in l ];
    I:=Ideal(E1,[Random(E1) : i in [1..100]]);
    J:=&*[I : i in [1..100]];
    JJ:=I^100;
    assert J eq JJ;
    _:=&meet[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    assert forall{ I : I in [Random(E1)*E1 : i in [1..100]] | not IsProductOfIdeals(I)};
    printf ".";
    assert forall{ I : I in [Random(E2)*E2 : i in [1..100]] | IsProductOfIdeals(I)};
    _:=[TraceDualIdeal(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    _:=[IsIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    _:=[MakeIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    printf ".";

    ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..200]]; 
    _:=&meet(ids);
    rr:=[ResidueRing(E1,I) : I in ids ];
    cc:=[ ColonIdeal(I,J) : I,J in ids[1..10]  ];

    O:=MaximalOrder(A);
    test,O_prod:=IsProductOfOrders(O);
    assert test;
    for i in [1..100] do
        _:=Ideal(O,<ideal< O_prod[i] | [Random(O_prod[i],3): j in [1..3]]> : i in [1..#O_prod] >);
        printf ".";
    end for;

    ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..20]]; 
    cc2:=[ TraceDualIdeal(TraceDualIdeal(I)*J) : I,J in ids  ];
    cc:=[ ColonIdeal(I,J) : I,J in ids  ];
    assert cc eq cc2;
    printf ".";

    // testing KnownPowers 
    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    I:=Conductor(E1);
    assert not IsInvertible(I);
    _:=I^2;
    is_def,I2:=IsDefined(I`KnownPowers,2);
    assert is_def and I2 eq I*I;
    _:=I^5;
    is_def,I4:=IsDefined(I`KnownPowers,4);
    assert is_def and I4 eq (I*I)*(I*I);
    is_def,I5:=IsDefined(I`KnownPowers,5);
    assert is_def and I5 eq (I*I)*(I*I)*I;

    SetAssertions(1);
    printf " all good!\n";


*/

