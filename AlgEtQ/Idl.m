/////////////////////////////////////////////////////
// Copyright 2025.
// Stefano Marseglia, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
//
// Distributed under the terms of the CC-BY 4.0 licence.
// https://creativecommons.org/licenses/by/4.0/
/////////////////////////////////////////////////////



freeze;

declare verbose AlgEtQIdl, 3;

declare type AlgEtQIdl;

declare attributes AlgEtQIdl : Index, //stores the index
                              Order, //order of definition. it might be smaller than the multiplicator ring
                              Algebra,
                              MultiplicatorRing,
                              Generators,
                              ZBasis,
                              KnownPowers, //an associative array storing the known powers of an ideal
                              IsPrime,
                              IsInvertible,
                              Inverse,
                              IsIntegral,
                              MinimalInteger,
                              PrimesAbove,
                              Factorization,
                              IsProductOfIdeals,
                              TraceDualIdeal,
                              Hash,
                              inclusion_matrix;

import "Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;

///# Ideals of orders in étale algebras over $\mathbb{Q}$
/// Let $R$ be an order in an étale algebra $A$ over $\mathbb{Q}$.
/// A `fractional ideal` over $R$, or fractional $R$-ideal, is a sub-$R$-module of $A$ whose underlying additive group is free of rank equal to the absolute dimension of $A$.
/// A fractional $R$-ideal is said to be `integral` if $I\subseteq R$.
/// Note that every overorder of $R$ is a fractional $R$-ideal.
///
/// In MAGMA, fractional ideals have type `AlgEtQIdl`. Elements will always be considered as elements of the algebra.

///## Creation

///hide-all
intrinsic Print(I::AlgEtQIdl)
{Prints the ideal.}
  printf"Ideal of %o", Order(I);
end intrinsic;

CreateAlgEtQIdl:=function(S,gens)
// Given S::AlgEtQOrd and some generators creates the new object
// The ZBasis is computed only if there are more generators than the dimension of the algebra.
    A:=Algebra(S);
    I:=New(AlgEtQIdl);
    I`Algebra:=A;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(A) then
        ZZ:=Integers();
        vprint AlgEtQIdl,3: "CreateAlgEtQIdl: too many gens";
        gens:=[g*s : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(A);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(A,P);
        assert #zb eq AbsoluteDimension(A);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    if (assigned S`IsMaximal and IsMaximal(S)) or #gens eq 1 then
        I`IsInvertible:=true;
        I`MultiplicatorRing:=S;
    end if;
    I`KnownPowers:=AssociativeArray();
    return I;
end function;
///hide-none

/// Given an order $S$ in an étale algebra and a sequence `gens` of elements coercible in the algebra, returns the fractional $S$-ideal generated by `gens`.}
intrinsic Ideal(S::AlgEtQOrd, gens::SeqEnum) -> AlgEtQIdl
{Given an order S in an étale algebra and a sequence gens of elements coercible in the algebra, returns the fractional S-ideal generated by gens.}
    A:=Algebra(S);
    gensA:=[];
    for g in gens do
        bool,gA:=IsCoercible(A,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensA,gA);
    end for;
    id:=CreateAlgEtQIdl(S,gensA);
    if #gensA eq 1 then
        id`MultiplicatorRing:=S;
    end if;
    return id;
end intrinsic;

/// Given an order $S$ which is a product of orders $S_i$ in the components of the parent étale algebra, and a tuple of fractional $S_i$-ideals $I_i$, returns the $S$-ideal corresponding to the direct sum of the $I_i$.}
intrinsic Ideal(S::AlgEtQOrd, idls::Tup) -> AlgEtQIdl
{Given an order S which is a product of orders S_i in the number fields generating the Algebra(S), and a Tup of ideals I_i of S_i, returns the S-ideal corresponding to the direct sum of the I_i.}
    A:=Algebra(S);
    test,SasProd:=IsProductOfOrders(S);
    require test : "The order needs to be a product.";
    require #SasProd eq #idls : "The sequence does not contain enough ideals to generate a lattice in Algebra(S).";
    require forall{ i : i in [1..#idls] | Order(idls[i]) eq SasProd[i]} : "The ideals are not defined over the components of S.";
    A:=Algebra(S);
    _,embs:=Components(A);
    gens:=&cat[ [embs[i](g) : g in Generators(idls[i])] : i in [1..#idls] ];
    I:=Ideal(S,gens);
    I`IsProductOfIdeals:=<true,idls>;
    return I;
end intrinsic;

/// Returns the fractional $S$-ideal generated by `gen`.
intrinsic Ideal(S::AlgEtQOrd, gen::Any) -> AlgEtQIdl
{Returns the fractional S-ideal generated by gen.}
    return Ideal(S,[gen]);
end intrinsic;

///ditto
intrinsic '*'(S::AlgEtQOrd, gen::AlgEtQElt) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///ditto
intrinsic '*'(gen::AlgEtQElt, S::AlgEtQOrd) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///ditto
intrinsic '*'(S::AlgEtQOrd, gen::RngIntElt) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///ditto
intrinsic '*'(gen::RngIntElt, S::AlgEtQOrd) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///ditto
intrinsic '*'(S::AlgEtQOrd, gen::FldRatElt) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///ditto
intrinsic '*'(gen::FldRatElt, S::AlgEtQOrd) -> AlgEtQIdl
{ " } // "
    return Ideal(S,gen);
end intrinsic;

///## Coercion of fractional ideals
/// Let $S$ and $T$ be orders in an étale algebra and let $I$ be a fractional $S$-ideal.
/// If $T \subseteq S$ then $I$ is naturally also a fractional $T$-ideal.
/// Otherwise, one can consider the fractional $T$-ideal $IT$ generated by $I$.
/// This is done using the operator `!!`.

/// Given an order $T$ and a fractional $S$-ideal $I$ for some order $S$ in the same étale algebra of $T$, returns the fractional $T$-ideal $IT$. If $T$ is a subset of $S$, then $IT$ and $I$ coincides as sets.
intrinsic '!!'(T::AlgEtQOrd,I::AlgEtQIdl) -> AlgEtQIdl
{Given an order T and a fractional S-ideal I for some order S in the same étale algebra of T, returns the fractional T-ideal IT. If T is a subset of S, then IT and I coincides as sets.}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        id:=Ideal(T,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=I`MultiplicatorRing; //..as well as the MultiplicatorRing
        end if;
        return id;
    else //in this case Order(I) is strictly contained in T
        out:=Ideal(T,Generators(I));
        if (assigned T`IsMaximal and IsMaximal(T)) or (assigned I`IsInvertible and IsInvertible(I)) then
            out`IsInvertible:=true;
            out`MultiplicatorRing:=T;
        end if;
        return out;
    end if;
end intrinsic;

///## Attributes

intrinsic Algebra(I::AlgEtQIdl) -> AlgEtQ
{Returns the étale algebra of the fractional ideal.}
    return I`Algebra;
end intrinsic;

intrinsic Order(I::AlgEtQIdl) -> AlgEtQOrd
{Returns the order of definition of the fractional ideal.}
    return I`Order;
end intrinsic;

/// Returns a $\mathbb{Z}$-basis of the fractional ideal.
intrinsic ZBasis(I::AlgEtQIdl)->SeqEnum[AlgEtQElt]
{Returns a Z-basis of the fractional ideal.}
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        A:=Algebra(I);
        S:=Order(I);
        gens:=[g*s : g in Generators(I) , s in ZBasis(S) ];
        if #Generators(I) eq 1 then
            zb:=gens; //gens is a ZBasis of I
        else
            dim:=AbsoluteDimension(A);
            M:=MatrixAtoQ(gens);
            d:=Integers()!Denominator(M);
            P:=hnf(crQZ(d*M));
            P:=(1/d)*crZQ(P);
            d:=Denominator(P); //this d might be different from Denomintor(M)
            hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
            // UNSAFE hash:=Hash(P);
            zb:=MatrixQtoA(A,P);
            assert #zb eq AbsoluteDimension(A);
            I`Hash:=hash;
        end if;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic Generators(I::AlgEtQIdl) -> SeqEnum[AlgEtQElt]
{Returns a set of generators of the fractional ideal.}
    if not assigned I`Generators then
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(Algebra(I));
    return I`Generators;
end intrinsic;

///## Hashing and equality
/// Let $I$ a fractional $S$-ideal in an étale algebra over $\mathbb{Q}$.
/// Let $P$ be the upper triangular Hermite normal form of the integer square matrix $d\cdot M$ where $M$ is the matrix whose rows are the coefficients of a $\mathbb{Z}$-basis of $I$ and $d$ is the least common denominator of its entries.
/// The `Hash` of $I$ is defined to be the sequence consisting of the least common denominator of $\frac{1}{d}\cdot P$ and the entries of the upper triangular part of $\frac{1}{d}\cdot P$.
/// This hashing method has no collisions and it is independent of the choice of $\mathbb{Z}-basis$ from which we start the procedure.
/// We observed that applying the in-built Hash function to the sequence defined above, while giving a smaller hash, it often leads to collisions.

intrinsic myHash(I::AlgEtQIdl)->SeqEnum[RngInt]
{Hash function.}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(Algebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

intrinsic 'eq'(I::AlgEtQIdl , J::AlgEtQIdl ) -> BoolElt
{Equality testing.}
    require Algebra(I) cmpeq Algebra(J) : "The ideals are not in the same algebra.";
    require Order(I) cmpeq Order(J) : "The ideals are not over the same order.";
    if  (not (assigned I`Hash and assigned J`Hash)) and
        (assigned I`Generators and assigned J`Generators and Generators(I) eq Generators(J)) then
        // to compute myHash we need compute an HNF. In this way we might avoid it.
        out:=true;
        //note that the set of generators is not unique for an ideal.
    else
        out:=myHash(I) eq myHash(J);
    end if;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtQIdl) do
            if att ne "inclusion_matrix" then // we exclude the attributes that depend on the ZBasis
                if assigned I``att and not assigned J``att then
                    J``att:=I``att;
                elif assigned J``att and not assigned I``att then
                    I``att:=J``att;
                end if;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

///ditto
intrinsic 'eq'(I::AlgEtQIdl, S::AlgEtQOrd) -> BoolElt
{Return if I eq S. I needs to be an ideal of S.}
  require Algebra(I) cmpeq Algebra(S) : "The order and the ideals do not live in the same algebra.";
  if Index(S, I) eq 1 then
      return I eq OneIdeal(S);
  else
      return false;
  end if;
end intrinsic;

///ditto
intrinsic 'eq'(S::AlgEtQOrd,I::AlgEtQIdl) -> BoolElt
{ " } // "
    return I eq S;
end intrinsic;

///## Coordinates with respect to the $\mathbb{Z}$-basis and inclusion
/// Inclusion testing of elements, orders and ideals in a given fractional ideal is performed by multiplying by the `inclusion matrix`. This matrix, which is stored in an attribute, is the inverse of the matrix with coefficients the $\mathbb{Z}$-basis of the order. If the output of the multiplication has integer coefficients then we have an inclusion.
/// The same matrix can be used to obtain the coordinates of a sequence of elements with respect to the $\mathbb{Z}$-basis.

/// Given a sequence of elements and a fractional ideal $I$, returns the sequence of coordinates of the elements with respect to the stored $\mathbb{Z}$-basis of $I$.
intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtQElt],I::AlgEtQIdl) -> SeqEnum
{Given a sequence of elements and a fractional ideal I, returns the sequence of coordinates of the elements with respect to the stored Z-basis of I.}
    require forall{x : x in seq | Algebra(x) cmpeq Algebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtQElt , I::AlgEtQIdl ) -> BoolElt
{Returns whether the element is in the given fractional ideal.}
    require Algebra(x) eq Algebra(I) : "the elements must lie in the same algebra of definition";
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

///ditto
intrinsic 'in'(x::RngIntElt , I::AlgEtQIdl ) -> BoolElt
{ " } // "
    return (Algebra(I)!x) in I;
end intrinsic;

///ditto
intrinsic 'in'(x::FldRatElt , I::AlgEtQIdl ) -> BoolElt
{ " } // "
    return (Algebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(S::AlgEtQOrd,I::AlgEtQIdl) -> BoolElt
{Inclusion testing.}
    require Order(I) eq S: "the second argument must be an ideal of the first argument";
    return OneIdeal(S) subset I;
end intrinsic;

///ditto
intrinsic 'subset'(I::AlgEtQIdl,S::AlgEtQOrd) -> BoolElt
{ " } // "
    require Order(I) eq S: "the first argument must be an ideal of the second argument";
    return I subset OneIdeal(S);
end intrinsic;

///ditto
intrinsic 'subset'(I1 :: AlgEtQIdl, I2 :: AlgEtQIdl) -> BoolElt
{ " } // "
  require Order(I1) eq Order(I2) : "The ideals must be in the same order.";
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

///## Index

/// Given a fractional ideal $I$ returns the determinant of the change of basis from a $\mathbb{Z}$-basis of $I$ to the basis of the parent algebra.
intrinsic Index(I::AlgEtQIdl) -> FldRatElt
{Given a fractional ideal I returns the determinant of the change of basis from a Z-basis of I to the basis of the parent algebra.}
  if not assigned I`Index then
    matT := MatrixAtoQ(ZBasis(I));
    I`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return I`Index;
end intrinsic;

/// Given fractional ideals $J$ and $I$ defined over the same order returns $[J:I] = [J:J \cap I]/[I : J \cap I]$.
intrinsic Index(J::AlgEtQIdl, I::AlgEtQIdl) -> FldRatElt
{Given fractional ideals J and I defined over the same order returns [J:I] = [J:J meet I]/[I : J meet I].}
  require Order(I) eq Order(J): "the ideals must be of the same order";
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;

/// Given an order $S$ and a fractional $S$-ideal $I$ returns $[S:I] = [S:S \cap I]/[I : S \cap I]$.
intrinsic Index(S::AlgEtQOrd, I::AlgEtQIdl) -> FldRatElt
{Given an ideal I of an order S returns [S:I] = [S:S cap I]/[I : S cap I].}
    require Order(I) eq S: "the ideal must be of the appropriate order";
    return Index(OneIdeal(S), I);
end intrinsic;


///## Special ideals

intrinsic OneIdeal(S::AlgEtQOrd) -> AlgEtQIdl
{Returns the ideal generated by the multiplicative unit of the given order.}
  if not assigned S`OneIdeal then
    S`OneIdeal := Ideal(S,One(S));
    S`OneIdeal`IsInvertible:=true;
    S`OneIdeal`MultiplicatorRing:=S;
  end if;
  return S`OneIdeal;
end intrinsic;

/// Computes the conductor of an order $R$, defined as the colon ideal $(R:\mathcal{O})$, where $\mathcal{O}$ is the maximal order of the algebra.
intrinsic Conductor(O::AlgEtQOrd) ->AlgEtQIdl
{Computes the conductor of an order, defined as the colon ideal (O:OK), where OK is the maximal order of the algebra.}
    if not assigned O`Conductor then
        A:=Algebra(O);
        OA:=MaximalOrder(A);
        cc:=ColonIdeal(O,O!!OneIdeal(OA));
        ZBasisLLL(cc);
        O`Conductor:=cc;
    end if;
    return O`Conductor;
end intrinsic;

///## Operations on ideals
/// The set of fractional $R$-ideals is closed under addition, multiplication, intersection and colon ideal.
/// More precisely, given two fractional $R$-ideals $I$ and $J$ in the étale algebra $A$, we define
/// - $I+J = \{ a + b : a \in I , b\in J \}$,
/// - $I*J = \{ a*b : a \in I, b \in J \}$,
/// - $I \cap J = \{ c \in A : c \in I \text{ and } c \in J \}$,
/// - $(I : J) = \{ c \in A : c\cdot J \subseteq I\}$.

intrinsic '+'(I::AlgEtQIdl , J::AlgEtQIdl ) -> AlgEtQIdl
{Returns the sum of the two fractional ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    if I eq J then
        return I;
    elif I subset J then
        return J;
    elif J subset I then
        return I;
    end if;
    S:=Order(I);
    gens:=Generators(I) cat Generators(J);
    return Ideal(S,gens);
end intrinsic;

intrinsic '*'(I::AlgEtQIdl , J::AlgEtQIdl ) -> AlgEtQIdl
{Returns the product of the two fractional ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    S:=Order(I);
    if I eq OneIdeal(S) then
        return J;
    elif J eq OneIdeal(S) then
        return I;
    end if;
    gI:=Generators(I);
    gJ:=Generators(J);
    if #gI eq 1 then //better for passing the attributes
        return J*gI[1];
    elif #gJ eq 1 then
        return I*gJ[1];
    else
        gens:=[i*j : i in gI, j in gJ ];
        out:=Ideal(S,gens);
        if assigned I`IsInvertible and assigned J`IsInvertible then
            out`IsInvertible:=IsInvertible(I) and IsInvertible(J);
        end if;
        return out;
    end if;
end intrinsic;

/// Returns the fractional ideal $x\cdot I$.
intrinsic '*'(I::AlgEtQIdl , x::AlgEtQElt ) -> AlgEtQIdl
{Returns the fractional ideal x*I.}
    bool,x:=IsCoercible(Algebra(I),x);
    if not bool then
        error "the element must be in the same algebra of I";
    else
        S:=Order(I);
        gens:=[i*x : i in Generators(I) ];
        id:=Ideal(S,gens);
        if assigned I`ZBasis and not assigned id`ZBasis then
            id`ZBasis:=[x*z : z in ZBasis(I)];
        end if;
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`IsInvertible then
            id`IsInvertible:=IsInvertible(I);
        end if;
        return id;
    end if;
end intrinsic;

///ditto
intrinsic '*'(x::AlgEtQElt, I::AlgEtQIdl) -> AlgEtQIdl
{Returns the fractional ideal x*I.}
    return I*x;
end intrinsic;

///ditto
intrinsic '*'(x::RngIntElt, I::AlgEtQIdl) -> AlgEtQIdl
{ " } // "
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

///ditto
intrinsic '*'(I::AlgEtQIdl, x::RngIntElt) -> AlgEtQIdl
{ " } // "
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

///ditto
intrinsic '*'(x::FldRatElt, I::AlgEtQIdl) -> AlgEtQIdl
{ " } // "
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

///ditto
intrinsic '*'(I::AlgEtQIdl, x::FldRatElt) -> AlgEtQIdl
{ " } // "
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

/// Returns the $n$-th power of the fractional ideal.
intrinsic '^'(I::AlgEtQIdl, n::RngIntElt) -> AlgEtQIdl
{Returns nth power of the fractional ideal.}
    S:=Order(I);
    power_invertible:=function(I,n)
    // given an invertible ideal I and positive integer n return I^n

    // Lemma:
    // Let I be an invertible fractional S-ideal generated globally by I=aS+bS.
    // For every integer N, we have I^N=a^NS+b^NS.
    // Proof: we will show it locally at every prime. Since I is invertible, then it is locally principal.
    // Pick a prime P. Then by Nakayama's Lemma I_P=(a/1)S_P or I_P=(b/1)S_P. wlog assume the first. Then I_P^N=(a^N/1)S_P. QED.
    //
    // Remark: this trick does not work for product of invertible ideals I and J.
    // One can have I_P1=(a) J_P1=(c) but I_P2=(a), J_P2=(d) so one cannot avoid the mixed products.
        TwoGeneratingSet(I);
        gg:=Generators(I);
        assert #gg le 2;
        out:=Ideal(Order(I),[g^n : g in gg]);
        out`IsInvertible:=true;
        if assigned I`MultiplicatorRing then
            out`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`PrimesAbove then
            out`PrimesAbove:=PrimesAbove(I);
        end if;
        if assigned I`Factorization then
            out`Factorization:=< <fac[1],n*fac[2]> : fac in Factorization(I) >;
        end if;
        return out;
    end function;
    power_positive:=function(I, n)
        id := I;
        n0:=0;
        output := OneIdeal(S);
        bin_exp:=IntegerToSequence(n,2);
        for i in [1..#bin_exp] do
            if bin_exp[i] eq 1 then
                n0 +:=2^(i-1);
                is_def,In0:=IsDefined(I`KnownPowers,n0);
                if is_def then
                    output := In0;
                else
                    output *:= id;
                    I`KnownPowers[n0]:=output;
                end if;
            end if;
            if i lt #bin_exp then
                ni:=2^i;
                is_def,Ini:=IsDefined(I`KnownPowers,ni);
                if is_def then
                    id:=Ini;
                else
                    id := id*id; // I^(2^i)
                    I`KnownPowers[ni]:=id;
                end if;
            end if;
        end for;
        return output;
    end function;
    if not IsDefined(I`KnownPowers,n) then
        if n eq 0 then
            output:=OneIdeal(S);
        elif n eq 1 then
            output:=I;
        else
            if n gt 0 then
                if assigned I`IsInvertible and IsInvertible(I) then
                    output:=power_invertible(I,n);
                else
                    output:=power_positive(I,n);
                end if;
            end if;
            if n lt 0 then
                invI:=Inverse(I);
                if n eq -1 then
                    output:=invI;
                else
                    output:=power_invertible(invI,-n);
                end if;
            end if;
        end if;
        I`KnownPowers[n]:=output;
    end if;
    return I`KnownPowers[n];
end intrinsic;

/// Given a fractional ideal $I$ of the order $S$, returns $S \cap I$.
intrinsic 'meet'(I::AlgEtQIdl, S::AlgEtQOrd) -> AlgEtQIdl
{Given a fractional ideal I of the order S, returns S cap I.}
    return S meet I;
end intrinsic;

///ditto
intrinsic 'meet'(S::AlgEtQOrd,I::AlgEtQIdl) -> AlgEtQIdl
{ " } // "
    output := OneIdeal(S) meet I;
    return output;
end intrinsic;

intrinsic 'meet'(I::AlgEtQIdl, J::AlgEtQIdl) -> AlgEtQIdl
{Given two fractional ideals over the same order, returns their intersection.}
// this code is inspired by H.Cohen "Advanced Topics in ...", page 36.]
// note that the hnf in Magma is not the same as in the book. This is why the matrix M and P are take in a slightly different way compared to the reference.
    require Order(I) eq Order(J): "the ideals must be defined over the same order";
    A:=Algebra(I);
    if I subset J then
        return I;
    end if;
    if J subset I then
        return J;
    end if;
    zb:=meet_zbasis(ZBasis(I),ZBasis(J));
    id:=Ideal(Order(I),zb);
    id`ZBasis:=zb;
    return id;
end intrinsic;

/// Given fractional ideals $I$ and $J$ over the same order returns their colon ideal $(I:J)$.
intrinsic ColonIdeal(I::AlgEtQIdl,J::AlgEtQIdl)->AlgEtQIdl
{Given fractional ideals I and J over the same order returns their colon ideal (I:J).}
    A:=Algebra(I);
    O := Order(I);
    require Order(J) eq O : "the ideals must be of the same order";
    if assigned J`Generators and #J`Generators eq 1 then
        j:=J`Generators[1];
        out:=(1/j)*I;
        return out;
    end if;
    // based on jv code
    N:=AbsoluteDimension(A);
    zbI:=ZBasis(I);
    //mIinv:=MatrixAtoQ(zbI)^-1;
    mIinv:=inclusion_matrix(I);
    zbJ:=ZBasis(J);
    bas:=AbsoluteBasis(A);
    M:=VerticalJoin([ Transpose( MatrixAtoQ([zj*bas[i] : i in [1..N]])*mIinv) : zj in zbJ] );
    d:=Denominator(M);
    P:=(1/d)*crZQ(hnf(crQZ(d*M)));
    P:=Transpose(P)^-1;
    zbIJ:=MatrixQtoA(A,P);
    IJ:=Ideal(O,zbIJ);
    IJ`ZBasis:=zbIJ; //we know that zbIJ is a ZBasis
    assert2 IJ*J subset I;
    return IJ;
end intrinsic;

/// Given an order $\mathcal{O}$ and a fractional $\mathcal{O}$-ideal $J$, returns $(\mathcal{O}:J)$.
intrinsic ColonIdeal(O::AlgEtQOrd,J::AlgEtQIdl)->AlgEtQIdl
{Given an order O and a fractional O-ideal J, returns (O:J).}
    require Order(J) eq O : "The ideal is not defined of the same order";
    return ColonIdeal(OneIdeal(O), J);
end intrinsic;

/// Given an order $\mathcal{O}$ and a fractional $\mathcal{O}$-ideal $I$, returns $(I:\mathcal{O})$.
intrinsic ColonIdeal(I::AlgEtQIdl,O::AlgEtQOrd)->AlgEtQIdl
{Given a fractional O-ideal I and an order O, returns (I:O).}
    require Order(I) eq O : "The ideal is not defined of the same order";
    return I; //since we require O=Order(I)
end intrinsic;

///## Invertibility and multiplicator ring
/// Let $I$ be a fractional $R$-ideal.
/// The `multiplicator ring` of $I$ is the biggest order $S$ such that $I$ is a fractional $S$-ideal.
/// It is easy to verify that the multiplicator ring of $I$ is the overorder $(I:I)$ of $R$.
/// We say that $I$ is `invertible` if $I\cdot (R:I) = R$.
/// If $I$ is invertible, we say that $(R:I)$ is its `inverse`.
/// This definition depends on the order of definition of $I$.
/// In fact, if $I$ is invertible then $R=(I:I)$.
/// If $R$ is the maximal order of the algebra, then every fractional $R$-ideal is invertible.

intrinsic IsInvertible(I::AlgEtQIdl) ->BoolElt
{Checks if the ideal I is invertible in its order of definition.}
    if not assigned I`IsInvertible then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        test:=One(O) in I*COI;
        I`IsInvertible:=test;
        if test then
            I`Inverse:=COI;
            I`MultiplicatorRing:=O;
            COI`IsInvertible:=true;
            COI`MultiplicatorRing:=O;
            COI`Inverse:=I;
            I`Inverse:=COI;
        end if;
    end if;
    return I`IsInvertible;
end intrinsic;

intrinsic Inverse(I::AlgEtQIdl) ->AlgEtQIdl
{Computes the inverse of a given invertible ideal.}
    require IsInvertible(I) : "The ideal is not invertible in the order of definition";
    if not assigned I`Inverse then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        COI`IsInvertible:=true;
        COI`MultiplicatorRing:=O;
        COI`Inverse:=I;
        I`Inverse:=COI;
    end if;
    return I`Inverse;
end intrinsic;

intrinsic MultiplicatorRing(I::AlgEtQIdl) -> AlgEtQOrd
{Computes the multiplicator ring of the given fractional ideal.}
    if not assigned I`MultiplicatorRing then
        R:=Order(I);
        if #Generators(I) eq 1 then
            I`MultiplicatorRing:=R;
        elif assigned R`IsMaximal and R`IsMaximal then
            I`MultiplicatorRing:=R;
        elif assigned I`IsInvertible and I`IsInvertible then
            I`MultiplicatorRing:=R;
        else
            A:=Algebra(I);
            zbS:=ZBasis(ColonIdeal(I,I));
            S:=Order(zbS : Check:=0 );
            I`MultiplicatorRing:=S;
        end if;
    end if;
    return I`MultiplicatorRing;
end intrinsic;

intrinsic MultiplicatorRing(R::AlgEtQOrd) -> AlgEtQOrd
{Returns the multiplicator ring of the order, that is, the order itself.}
    return R;
end intrinsic;


///hide-all
//----------
// On Sequences
//----------

intrinsic '&+'(seq::SeqEnum[AlgEtQIdl])->AlgEtQIdl
{Returns the sum of the fractional ideals in the sequence.}
    id:=Ideal(Order(seq[1]),&cat[Generators(I):I in seq]);
    return id;
end intrinsic;
// an analogous definition of &* seems to be very slow, probably because the number of generators grows too fast.
///hide-none

/// Returns a random element of the given fractional ideal with coefficients with respect to the stored $\mathbb{Z}$-basis bounded by `bd`. One can allow zero-divisors using the parameter `ZeroDivisorsAllowed`, which is set to false by default.
intrinsic Random(I::AlgEtQIdl , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random element of I with coefficcients with respect to the stored Z-basis bounded by bd. One can allow zero-divisors using the parameter ZeroDivisorsAllowed, which is set to false by default.}
    require bd gt 0 : "The bound needs to be a positive integer.";
    ZBasisLLL(I); // to keep it small
    B := ZBasis(I);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

/// Returns a random element of the given fractional ideal. The coefficients with respect to the stored $\mathbb{Z}$-basis can be bounded by setting the parameter `CoeffRange`. One can allow zero-divisors using the parameter `ZeroDivisorsAllowed`, which is set to false by default.
intrinsic Random(I::AlgEtQIdl : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random (small coefficient) element of I. The range of the random coefficients can be increased by giving the optional argument CoeffRange. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false.}
      return Random(I,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;

///## Various properties of the ideals

/// Returns if the argument is a product of ideals in the number fields defining the algebra. If so, it returns also the sequence of these ideals (in the appropriate orders). We require the order of definition of the ideal to be its multiplicator ring.
intrinsic IsProductOfIdeals(I::AlgEtQIdl) -> BoolElt, Tup
{Returns if the argument is a product of ideals in the number fields defining the algebra. If so, it returns also the sequence of these ideals (in the appropriate orders). Note: we require Order(I) to be the MultiplicatorRing(I).}
    if not assigned I`IsProductOfIdeals then
        O:=Order(I);
        require O eq MultiplicatorRing(I) : "The ideal needs to be defined over its multiplicator ring.";
        A:=Algebra(O);
        test,orders:=IsProductOfOrders(O);
        if test then
            nf,_,projs:=Components(A);
            zb:=ZBasis(I);
            ideals:=< ideal< orders[i] | [ projs[i](z) : z in zb ] > : i in [1..#orders] >;
            I`IsProductOfIdeals:=<true, ideals>;
        else
            I`IsProductOfIdeals:=<false,<>>;
        end if;
    end if;
    return Explode(I`IsProductOfIdeals);
end intrinsic;

/// Given two integral ideals $I$ and $J$ over the same order $S$, returns whether $I+J=S$.}
intrinsic IsCoprime(I::AlgEtQIdl,J::AlgEtQIdl) -> BoolElt
{Given two integral ideals I and J over the same order S, returns whether I+J=S.}
    require Algebra(I) cmpeq Algebra(J) : "the ideals must lie in the same algebra";
    S:=Order(J);
    require Order(I) eq S: "the ideals must be over the same order";
    if I eq J then
        return false;
    end if;
    if assigned I`IsPrime and assigned J`IsPrime then
        if IsPrime(I) and IsPrime(J) then
            return true; //we already know that the ideals are distinct
        end if;
    end if;
    require IsIntegral(I) and IsIntegral(J): "the ideals must be integral";
    g:=GCD(MinimalInteger(I),MinimalInteger(J));
    if g eq 1 then
        return true;
    else
        return (One(S) in I+J); //here we generate a new ideal, which is expensive.
    end if;
end intrinsic;

intrinsic IsIntegral(I::AlgEtQIdl) -> BoolElt
{Returns whether the given fractional ideal is integral in its order of definition.}
    if not assigned I`IsIntegral then
        S:=Order(I);
        I`IsIntegral:=I subset S;
    end if;
    return I`IsIntegral;
end intrinsic;

/// Given a fractional $S$-ideal $I$, returns the ideal $d*I$, where $d$ is the smallest integer such that $d\cdot I$ is integral. Compare with the intrinsic `SmallRepresentative`.
intrinsic MakeIntegral(I::AlgEtQIdl) -> AlgEtQIdl,RngIntElt
{Given a fractional S-ideal I, returns the ideal d*I,d when d is the smallest integer such that d*I is integral in S. Compare with SmallRepresentative.}
    if IsIntegral(I) then return I,1; end if;
    S:=Order(I);
    d:=LCM(&cat[ [Denominator(x_coord) : x_coord in x] : x in AbsoluteCoordinates(Generators(I),S)]);
    dI:=d*I;
    assert2 dI subset S;
    return dI, d;
end intrinsic;

intrinsic MinimalInteger(I::AlgEtQIdl) -> RngIntElt
{Returns the smallest integer contained in the given fractional ideal, which must be integral.}
    if not assigned I`MinimalInteger then
        require IsIntegral(I): "the ideal must be integral";
        ZZ:=Integers();
        coord:=AbsoluteCoordinates([One(Algebra(I))],I)[1];
        min:=LCM([ Denominator(c) : c in Eltseq(coord)]);
        assert2 min in I;
        I`MinimalInteger:=min;
    end if;
    return I`MinimalInteger;
end intrinsic;


/// Given an invertible fractional ideal $I$ and an integral ideal $J$, defined over the same order, returns a unit $x$ of the parent algebra such that $x\cdot I$ is an integral fractional ideal coprime with $J$, together with the product $x\cdot I$.
intrinsic CoprimeRepresentative(I::AlgEtQIdl,J::AlgEtQIdl) -> AlgEtQElt,AlgEtQIdl
{Given an invertible fractional ideal I and an integral ideal J, defined over the same order, returns a unit x of the parent algebra such that x*I is an integral fractional ideal coprime with J, together with the product x*I.}
    require IsIntegral(J) : "the second ideal must be integral";
    S:=Order(I);
    require S eq Order(J): "the ideals must be defined over the same order";
    x:=One(Algebra(I));
    xI:=I;
    while not (IsIntegral(xI) and IsCoprime(xI,J)) do
        x:=Random(Inverse(I)); //Inverse is cached
        xI:=x*I;
    end while;
    vprintf AlgEtQIdl,2: "CoprimeRepresentative:\n
                            I = %o\n,xI = %o\n",PrintSeqAlgEtQElt(ZBasis(I)),PrintSeqAlgEtQElt(ZBasis(xI));
    return x,xI;
end intrinsic;

/* TESTS

    printf "### Testing Ideals:";
    //AttachSpec("~/packages_github/AlgEt/spec");
    SetVerbose("AlgEtQIdl",1);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    for i in [1..100] do
        a:=Random(A);
        assert 1 eq #{Ideal(E1,a),a*E1,E1*a};
        assert 1 eq #{Ideal(E2,a),a*E2,E2*a};
        assert a*E2 eq E2!!(a*E1);
        assert E1!!(E2!!(a*E1)) ne a*E1;
        printf ".";
    end for;

    _:={ Random(E1)*E1 : i in [1..100] };
    _:=a*E1 + E1!!(a*E2);
    _:=&*[Random(E1)*E1 : i in [1..100]];
    _:=&*[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    l:=[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    assert forall{ I : I in l | not assigned I`ZBasis };
    assert forall{ I : I in l | I eq Ideal(E1,ZBasis(I))};
    assert forall{ I : I in l | assigned I`ZBasis };
    _:=&+[ i eq j select 1 else 0 : i,j in l ];
    I:=Ideal(E1,[Random(E1) : i in [1..100]]);
    J:=&*[I : i in [1..100]];
    JJ:=I^100;
    assert J eq JJ;
    _:=&meet[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    assert forall{ I : I in [Random(E1)*E1 : i in [1..100]] | not IsProductOfIdeals(I)};
    printf ".";
    assert forall{ I : I in [Random(E2)*E2 : i in [1..100]] | IsProductOfIdeals(I)};
    _:=[TraceDualIdeal(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    _:=[IsIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    _:=[MakeIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    printf ".";

    ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..200]];
    _:=&meet(ids);
    rr:=[ResidueRing(E1,I) : I in ids ];
    cc:=[ ColonIdeal(I,J) : I,J in ids[1..10]  ];

    O:=MaximalOrder(A);
    test,O_prod:=IsProductOfOrders(O);
    assert test;
    for i in [1..100] do
        _:=Ideal(O,<ideal< O_prod[i] | [Random(O_prod[i],3): j in [1..3]]> : i in [1..#O_prod] >);
        printf ".";
    end for;

    ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..20]];
    cc2:=[ TraceDualIdeal(TraceDualIdeal(I)*J) : I,J in ids  ];
    cc:=[ ColonIdeal(I,J) : I,J in ids  ];
    assert cc eq cc2;
    printf ".";

    // testing KnownPowers
    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    I:=Conductor(E1);
    assert not IsInvertible(I);
    _:=I^2;
    is_def,I2:=IsDefined(I`KnownPowers,2);
    assert is_def and I2 eq I*I;
    _:=I^5;
    is_def,I4:=IsDefined(I`KnownPowers,4);
    assert is_def and I4 eq (I*I)*(I*I);
    is_def,I5:=IsDefined(I`KnownPowers,5);
    assert is_def and I5 eq (I*I)*(I*I)*I;

    SetAssertions(1);
    printf " all good!";
*/
