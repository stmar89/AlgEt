/////////////////////////////////////////////////////
// Copyright 2025.
// Stefano Marseglia, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
// 
// Distributed under the terms of the CC-BY 4.0 licence.
// https://creativecommons.org/licenses/by/4.0/
/////////////////////////////////////////////////////



freeze;

declare verbose AlgEtQOrd, 3;

declare type AlgEtQOrd;

declare attributes AlgEtQ : MaximalOrder,
                           ProductOfEquationOrders,
                           EquationOrder,
                           KnownOrders; // This is a AssociativeArray indexed by rational numbers q:
                                        // in the key q we store all orders S in the algebra such that q=Index(S),
                                        // which is the index with respect to the fixed basis of A.
                                        // We store them, because to avoid creating multiple copies of the same order.
                                        // In particular, this is more efficient for the attributes.
                                        // The attribute is populated at creation of the order.

declare attributes AlgEtQOrd : IsMaximal,
                              IsProductOfOrders,
                              IsProductOfOrdersInFactorAlgebras,
                              Index,
                              ZBasis,
                              Generators,
                              OneIdeal,
                              Algebra,
                              TraceDualIdeal,
                              Conductor,
                              IsGorenstein,
                              IsBass,
                              Hash,
                              inclusion_matrix;

///hide-all
intrinsic Print(A::AlgEtQOrd)
{Print the order.}
  printf"Order in %o", A`Algebra;
end intrinsic;

intrinsic IsCoercible(S::AlgEtQOrd, x::.) -> BoolElt, Any
{Return whether x is coercible into S and the result if so.}
    bool,x:=IsCoercible(Algebra(S),x);
    if bool and x in S then
        return true,x;
    else
        return false,_;
    end if;
end intrinsic;

//----------
// Auxiliary functions
//----------

crZQ:=function(M)
//given a matrix M over the Integers() changes the base ring to Rationals()
    return ChangeRing(M,Rationals());
end function;

crQZ:=function(M)
//given a matrix M over the Rationals() changes the base ring to Integers()
    return ChangeRing(M,Integers());
end function;

Columns:=function(M)
    return Rows(Transpose(M));
end function;

hnf:=function(M)
//input: a matrix over the Integers() 
//output: the matrix in HNF
    N:=Rank(M);
    H:=HermiteForm(M);
    H:=Matrix(Rows(H)[1..N]);
    return H;
end function;

MatrixAtoQ:=function(gens)
//input:  a sequence of elements of an AlgEtQ A
//output: a matrix over Rationals() whose coordinates are the AbsoluteCoordinates of gens
    return Matrix([AbsoluteCoordinates(g) : g in gens]);
end function;

MatrixAtoZ:=function(gens)
//return a matrix with integers entries which rows the elements of gens
    return crQZ(MatrixAtoQ(gens));
end function;

MatrixQtoA:=function(A,P)
//given a matrix with Integer or Rational entries, returns a sequence of elements of A, corresponding to the rows.
    abs:=AbsoluteBasis(A);
    abs_dim:=AbsoluteDimension(A);
    N:=#Components(A);
    rows:=[ Eltseq(r) : r in Rows(P)];
    Nrow:=#rows;
    assert #Columns(P) eq abs_dim;
    // we first do the operations component-wise, and then create the element of A
    // in this way we save many calls of IsCoercible
    out_new:=<>;
    for j in [1..N] do
        Append(~out_new,[ &+[r[i]*Components(abs[i])[j] : i in [1..abs_dim]] : r in rows]);
    end for;
    out:= [ A!<out_new[j][r] : j in [1..N]> : r in [1..Nrow] ]; 
    return out;
end function;

///hide-none

///# Orders in étale algebras over $\mathbb{Q}$
/// Let $A$ be an étale algebra over $\mathbb{Q}$. An `order` in $A$ is a subring $R$ of $A$ whose underlying additive group is a free abelian group of rank equal to the absolute dimension of $A$.
/// Given an order $R$ in $A$, we say that $S$ is an `overorder` of $R$ if $R\subseteq S$.
/// In MAGMA, orders have type `AlgEtQOrd`. Elements will always be considered as elements of the algebra.

///## Creation
/// Whenever we create an order, we populate the attributes `Generators` and `ZBasis`.
/// Unless the parameter `Check` is set to $0$, the `ZBasis` is put in a canonical form (we use the Hermite normal form of the numerators and divide by the denominators). The entries of the corresponding upper triangular matrix uniquely determine the order and are used for hashing it. 

/// Returns the order generated by a given sequence of elements. The parameter `Check` (default $100$) determines how many times the program tries to obtain a multiplicatively closed lattice by adding the product of the given generators. If `Check` is $0$ then this step is skipped. The parameter `CheckIsKnownOrder` determines whether the program checks if the order is already known, i.e. in the attribute `KnownOrders` of the algebra. The default value is true.
intrinsic Order( gens::SeqEnum[AlgEtQElt] : Check:=100 , CheckIsKnownOrder:=true ) -> AlgEtQOrd
{Returns the order generated by a given sequence of elements. The parameter Check (default 100) determines how many times the program tries to obtain a multiplicatively closed lattice by adding the product of the given generators. If Check 0 then this step is skipped. The vararg CheckIsKnownOrder determines whether the program checks if the order is already known, i.e. in the attribute KnownOrders of the algebra. The default value is true.}
    A:=Universe(gens);
    gens:=Setseq(Seqset(gens));// we remove duplicates
    dim:=AbsoluteDimension(A);
    R:=New(AlgEtQOrd);
    R`Algebra:=A;
    require forall{g : g in gens | IsIntegral(g) } : "The elements are not all integral, hence do not generate an order.";
    if Check gt 0 then 
        gens0:=gens;
        if not One(A) in gens then
            gens0:=[One(A)] cat gens0;
        end if;
        M:=MatrixAtoQ(gens0);
        d:=Denominator(M);
        P:=crZQ(hnf(crQZ(d*M)))/d;
        gens0:=MatrixQtoA(A,P);
        fail:=0;
        repeat
            P_old:=P;
            gens0 cat:= [(g1*g2) : g1,g2 in gens0];
            M:=MatrixAtoQ(gens0);
            d:=Denominator(M);
            M:=crQZ(M*d);
            P:=crZQ(hnf(M))/d;
            gens0:=MatrixQtoA(A,P);
            fail +:=1;
            go:=Rank(P_old) eq dim and P eq P_old;
        until go or fail gt Check;
        if fail gt Check then 
            error "The program could not generate a multiplicatively closed set from the given generators. Try to increase the value of Check, or choose different generators.";
        end if;
        d:=Denominator(P); //this d might be different from Denomintor(M)
        R`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        // UNSAFE R`Hash:=Hash(P);
        zb:=MatrixQtoA(A,P);
    else
    //we assume that gens is a ZBasis of a multiplicativly closed lattice
        zb:=gens;
    end if;

    assert #zb eq dim;
    if #gens le dim then
        R`Generators:=gens;
    else
        R`Generators:=zb;
    end if;
    R`ZBasis:=zb;
    assert2 One(A) in R;
    if CheckIsKnownOrder then
        IsKnownOrder(~R);
    end if;
    return R;
end intrinsic;

intrinsic Order(A::AlgEtQ , orders::Tup) -> AlgEtQOrd
{Given an étale algebra and a tuple of orders in the components of the étale algebra, it generates the direct sum order.}
    nf,embs,projs:=Components(A);
    require #nf eq #orders and forall{ i : i in [1..#orders] | NumberField(orders[i]) eq nf[i]} and 
forall{ S : S in orders | Type(S) in {RngCyc,RngOrd} } : "The second input should be a sequence of orders in the number fields defining A";
    gens:=&cat[ [ embs[i](z) : z in AbsoluteBasis(orders[i]) ] : i in [1..#nf] ];
    O:=Order(gens : Check:=0); // the gens given generate a multiplicatively closed lattice in A
    assert2 O eq Order(gens);
    O`IsProductOfOrders:=<true,orders>;
    return O;
end intrinsic;

///## Equation orders
/// If $a$ is the stored primitive element of $A$ then we refer to the order $\mathbb{Z}[a]$ as the `equation order` of $A$.

intrinsic EquationOrder(A::AlgEtQ) -> AlgEtQOrd
{Returns the monogenic order of the étale algebra, which depends on the stored primitive element.}
    if not assigned A`EquationOrder then
        require PrimeField(A) eq BaseField(A) : "Defined only for algebras over the Rationals()";
        pow:=PowerBasis(A);
        E:=Order(pow : Check:=0); //the PowerBasis generates a multiplicatively closed lattice
        assert2 E eq Order([pow[2]]);
        E`Generators:=[pow[2]]; // I want the genertor set to be small, so I put only the primitive element
        A`EquationOrder:=E;
    end if;
    return A`EquationOrder;
end intrinsic;

intrinsic ProductOfEquationOrders(A::AlgEtQ)->AlgEtQOrd
{Given an étale algebra A, returns the order consisting of the product of the equation orders of the number fields.}
    if not assigned A`ProductOfEquationOrders then
        E:=Order( A , <EquationOrder(E) : E in Components(A)> );
        A`ProductOfEquationOrders := E;
    end if;
    return A`ProductOfEquationOrders ;
end intrinsic;

///## Maximal Order
/// If $A$ has components $K_1,\ldots,K_n$ then product $\mathcal{O}_A$ of the ring of integers $\mathcal{O}_{K_i}$ of $K_i$ is an order, which contains every other order of $A$. For this reason, we refer to $\mathcal{O}_A$ as the `maximal order` of $A$.

intrinsic MaximalOrder(A::AlgEtQ)->AlgEtQOrd
{Returns the maximal order of the étale algebra A. It is the direct sum of the ring of integers of the number fields composing the algebra.}
    if not assigned A`MaximalOrder then    
        O:=Order( A , <MaximalOrder(E) : E in Components(A)> );
        ZBasisLLL(O);
        O`IsMaximal:=true;
        A`MaximalOrder:=O;
    end if;
    return A`MaximalOrder;
end intrinsic;

intrinsic IsMaximal(S::AlgEtQOrd) -> BoolElt
{Returns whether the given order is the maximal order of the étale algebra.}
    if not assigned S`IsMaximal then
        O:=MaximalOrder(Algebra(S));
        S`IsMaximal:=S eq O;
    end if;
    return S`IsMaximal;
end intrinsic;

///## The attribute `KnownOrders`
/// An étale algebra $A$ has an attribute `KnownOrders`, in which all previously constructed orders are stored.
/// Whenever the creation intrinsic for orders is called, the program checks if the orders has already been constructed. This is done to prevent the creation of the same order multiple times. This check can be turned off with the appropriate parameter.

intrinsic IsKnownOrder(~R::AlgEtQOrd)
{This procedure checks whether the given order is already in the list of known orders of the parent algebra. If so then it replaces the given order with the stored copy. If not, it adds is added to the storage.}
    A:=Algebra(R);
    // new with AssociativeArray. Sorting the orders, should make it faster.
    if not assigned A`KnownOrders then
        A`KnownOrders:=AssociativeArray();
        A`KnownOrders[Index(R)]:={@ R @};
    else
        ind:=Index(R);
        if not IsDefined(A`KnownOrders,ind) then
            A`KnownOrders[ind]:={@ R @};
        else
            if exists(S){ T : T in A`KnownOrders[ind] | R eq T } then // this equality is done on the Hash level,
                                                                      // which means that 
                R:=S;
            else
                Include(~A`KnownOrders[ind],R);
            end if;
        end if;
    end if;
end intrinsic;

///## Main attributes of an order

intrinsic Algebra(S::AlgEtQOrd) -> AlgEtQ
{Returns the algebra of the order.}
  return S`Algebra;
end intrinsic;

/// Returns the stored $\mathbb{Z}$-basis of the order.
intrinsic ZBasis(S::AlgEtQOrd)->SeqEnum[AlgEtQElt]
{Return a Z-basis of the order.}    
    // assigned at creation
    return S`ZBasis;
end intrinsic;

/// Return a set of generators as a \mathbb{Z}}-algebra of the order.
intrinsic Generators(S::AlgEtQOrd)->SeqEnum[AlgEtQElt]
{Return a set of generators (as a Z-algebra) of the order.}    
    // assigned at creation
    return S`Generators;
end intrinsic;

///## Equality
/// Equality of orders is performed using the `Hash` attribute which is constructed as follows.
/// Let $S$ be an order. 
/// Let $P$ be the upper triangular Hermite normal form of the integer square matrix $d\cdot M$ where $M$ is the matrix whose rows are the coefficients of a $\mathbb{Z}$-basis of $S$ and $d$ is the least common denominator of its entries.
/// The `Hash` of $S$ is defined to be the sequence consisting of the least common denominator of $\frac{1}{d}\cdot P$ and the entries of the upper triangular part of $\frac{1}{d}\cdot P$. 
/// This hashing method has no collisions and it is independent of the choice of $\mathbb{Z}-basis$ from which we start the procedure.
/// We observed that applying the in-built Hash function to the sequence defined above, while giving a smaller hash, it often lead to collisions.

intrinsic myHash(S::AlgEtQOrd)->SeqEnum[RngInt]
{Hash function for AlgEtQOrd.}
// two orders have the hash iff they are equal
    if not assigned S`Hash then
        /* OLD
        P:=MatrixAtoQ(ZBasis(S));
        d:=Denominator(P);
        P:=crZQ(hnf(crQZ(d*P)))/d;
        */
        M:=MatrixAtoQ(ZBasis(S));
        d:=Denominator(M);
        M:=crQZ(M*d);
        P:=crZQ(hnf(M))/d;
        assert2 IsUpperTriangular(P);
        // UNSAFE S`Hash:=Hash(P);
        dim:=AbsoluteDimension(Algebra(S));
        d:=Denominator(P); //this d might be different from Denomintor(M)
        S`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
    end if;
    return S`Hash;
end intrinsic;

intrinsic 'eq'(O1::AlgEtQOrd,O2::AlgEtQOrd)->BoolElt
{Checks equality of orders.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same etale algebra";
    if 
    //O1`Generators eq O2`Generators or O1`ZBasis eq O2`ZBasis or //this seems to be slowe
    myHash(O1) eq myHash(O2) then 
        out:=true;
    else
        out:=false;
    end if;
    vprintf AlgEtQOrd,3 : "output of equality = %o\n",out;
    return out;
end intrinsic;

///## Inclusion and coordinates
/// Inclusion testing of elements, orders and ideals in a fixed order is performed by multiplying by the `inclusion matrix`. This matrix, which is stored in an attribute, is the inverse of the matrix with coefficients the $\mathbb{Z}$-basis of the order. If the output of the multiplication has integer coefficients then we have an inclusion.
/// The same matrix can be used to obtain the coordinates of a sequence of elements with respect to the $\mathbb{Z}$-basis.

inclusion_matrix:=function(O)
// the inclusion matrix is simply the inverse of the matrix MatrixAtoQ(ZBasis(O)).
// This allows to check if an element is in O by simply making one matrix multiplication, rather then
// solving a system (as in AbsoluteCoordinates). It is much faster.
// O can also be an ideal.
    if not assigned O`inclusion_matrix then
        zO:=ZBasis(O);
        O`inclusion_matrix:=<MatrixAtoQ(zO)^-1,zO>; 
    end if;
    assert2 ZBasis(O) eq O`inclusion_matrix[2]; // if the ZBasis(O) is changed and inclusion_matrix is not deleted
                                                // the assert will fail.
    return Explode(O`inclusion_matrix);
end function;

intrinsic 'in'(x::AlgEtQElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of an element in the order.} 
    require Algebra(x) cmpeq Algebra(O) : "the algebra is not the same";
    /* //this check succeeds very rarely, and makes the code a bit slower.
    if (assigned O`Generators and x in O`Generators)
        or (assigned O`ZBasis and x in O`ZBasis) then
        return true;
    end if;
    */
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],O)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of elements.}
    return (Algebra(O)!x) in O;
end intrinsic;

intrinsic 'in'(x::FldRatElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of elements.} 
    return (Algebra(O)!x) in O;
end intrinsic;

intrinsic 'subset'(O1 :: AlgEtQOrd, O2 :: AlgEtQOrd) -> BoolElt
{Checks if the first argument is inside the second.}
  require Algebra(O1) cmpeq Algebra(O2) : "The orders must be in the same algebra.";
  if not Index(O2, O1) in Integers() then
    return false;
  end if;
  return forall{z : z in Generators(O1) | z in O2 };
end intrinsic;

/// Returns the absolute coordinates of a sequence of elements  with respect to the stored $\mathbb{Z}$-basis of the given order.
intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtQElt],O::AlgEtQOrd) -> SeqEnum
{Returns the absolute coordinates of a sequence of elements  with respect to the stored Z-basis of the given order.}
    require forall{ x : x in seq | Algebra(x) cmpeq Algebra(O)} : "the algebra is not the same";
    Minv:=inclusion_matrix(O);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

///## Special and random elements in an order

intrinsic One(S::AlgEtQOrd)->AlgEtQElt
{Returns the multiplicative unit of the order.}
    A:=Algebra(S);
    return One(A);
end intrinsic;

intrinsic Zero(S::AlgEtQOrd)->AlgEtQElt
{Returns the additive neutral element of the order.}
    A:=Algebra(S);
    return Zero(A);
end intrinsic;

/// Returns a random element of the given order with coefficients with respect to the stored $\mathbb{Z}$-basis bounded by `bd`. One can allow zero-divisors using the parameter `ZeroDivisorsAllowed`, which is set to false by default.
intrinsic Random(O::AlgEtQOrd , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random element of O with coefficcients with respect to the stored Z-basis bounded by bd. One can allow zero-divisors using the parameter ZeroDivisorsAllowed, which is set to false by default.}
    require bd gt 0 : "The bound needs to be a positive integer.";
    ZBasisLLL(O); // to keep the element small.
    B := ZBasis(O);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

/// Returns a random element of the given order. The coefficients with respect to the stored $\mathbb{Z}$-basis can be bounded by setting the parameter `CoeffRange`. One can allow zero-divisors using the parameter `ZeroDivisorsAllowed`, which is set to false by default.
intrinsic Random(O::AlgEtQOrd : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random (small coefficient) element of O. The range of the random coefficients can be increased by giving the optional argument CoeffRange. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which is set to false by default.}
      return Random(O,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;


//----------
// Index
//----------

/// Given an order $T$ returns the determinant of the change of basis from a $\mathbb{Z}-basis of $T$ to the basis of the parent algebra.
intrinsic Index(T::AlgEtQOrd) -> FldRatElt
{Given an order T returns the determinant of the change of basis from a Z-basis of T to the basis of the parent algebra.}
  if not assigned T`Index then
    matT:=MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

/// Given two orders $S$ and $T$ returns the ratio of their indices. If $T subset S$ the outputs is the index of the inclusion, that is, it equals $[S:T] = \#S/T$.
intrinsic Index(S::AlgEtQOrd, T::AlgEtQOrd) -> FldRatElt
{Given two orders S and T returns the ratio of their indices. If T subset S the outputs is the index of the inclusion, that is, it equals [S:T] = \#S/T.}
  assert Algebra(T) cmpeq Algebra(S);
  elt := Index(T)/Index(S);
  if IsCoercible(Integers(), elt) then
    elt := Integers() ! elt;
  end if;
  return elt;
end intrinsic;

///## Product and intersection of orders

intrinsic '*'(O1::AlgEtQOrd,O2::AlgEtQOrd)->AlgEtQOrd
{Returns the order generated by the orders O1 and O2.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if O1 eq O2 then
        return O1;
    end if;
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O1;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O2;
    end if;
    if O1 subset O2 then
        return O2;
    end if;
    if O2 subset O1 then
        return O1;
    end if;
    gens:=Setseq( Seqset(Generators(O1) cat Generators(O2)) );
    return Order(gens);
end intrinsic;

meet_zbasis:=function(zb1,zb2)
//Returns the ZBasis of the intersection of the lattices gerated by the gven two Z-bases.
    A:=Algebra(zb1[1]);
    N:=#zb1;
    MI:=crZQ(MatrixAtoQ(zb1));
    MJ:=crZQ(MatrixAtoQ(zb2));
    dI:=Integers() ! Denominator(MI);
    dJ:=Integers() ! Denominator(MJ);
    d:=LCM(dI,dJ);
    MI:=crQZ(d*MI);
    MJ:=crQZ(d*MJ);
    MZ:=ZeroMatrix(Integers(),N,N);
    M:=Matrix(HorizontalJoin(VerticalJoin(MI,MJ),VerticalJoin(MI,MZ)));
    M:=hnf(M);
    //the hnf of zb1 meet zb2 is the lower-right quadrant of M
    P:=Matrix(N,N,[M[i,j] : i,j in [N+1..2*N]]);
    P:=(1/d)*crZQ(P);
    zb:=MatrixQtoA(A,P);
    return zb;
end function;

intrinsic 'meet'(O1::AlgEtQOrd,O2::AlgEtQOrd)->AlgEtQOrd
{Returns the order given by the intersection of two given orders.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O2;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O1;
    end if;
    if O1 eq O2 then
        return O1;
    end if;
    if O1 subset O2 then
        return O1;
    end if;
    if O2 subset O1 then
        return O2;
    end if;
    zb:=meet_zbasis(ZBasis(O1),ZBasis(O2));
    O:=Order(zb : Check:=0 ); //the intersecion of two orders is multiplicatively closed
    assert2 O eq Order(zb);
    return O;
end intrinsic;

///## Orders which are direct products of orders

intrinsic IsProductOfOrdersInComponents(O::AlgEtQOrd)->BoolElt, Tup
{Returns whether the argument is a product of orders in the components of its parent algebra. If so, it returns also a tuple containing these orders.}
    return IsProductOfOrders(O);
end intrinsic;

///ditto
intrinsic IsProductOfOrders(O::AlgEtQOrd)->BoolElt, Tup
{Returns whether the argument is a product of orders in the components of its parent algebra. If so, it returns also a tuple containing these orders.}
    if not assigned O`IsProductOfOrders then
        A:=Algebra(O);
        idem:=OrthogonalIdempotents(A);
        test:=forall{x : x in idem | x in O};
        if test then
            nf,_,projs:=Components(A); 
            if #nf eq 1 then
                orders:=< Order([ projs[1](z) : z in ZBasis(O) ])  >;
            else
                zb:=ZBasis(O);
                require PrimeField(A) eq BaseField(A) : "We require the algebra to be defined over the Rationals(). The reason is that we don't have a functioning method to create orders in relative number fields which are not over the maximal order of the base field. One can still check if the order O is a product by cehcking if OrthogonalIdempotents(A) are in O."; 
                orders:=< Order( [ projs[i](z) : z in zb ] ) : i in [1..#idem] >;
                assert2 O eq Order(A,orders);
            end if;
            O`IsProductOfOrders:=<true,orders>;
        else
            O`IsProductOfOrders:=<false,<>>;
        end if;
    end if;
    return Explode(O`IsProductOfOrders);
end intrinsic;

intrinsic IsProductOfOrdersInFactorAlgebras(S::AlgEtQOrd)->BoolElt,SeqEnum[AlgEtQElt]
{Returns whether the given order is a product of orders living in some factor algebras of the parent algebra. 
This is equivalent for the given order to contain some idempotents of the algebra other than 0 and 1. If this is the case, it returns also the idempotents.}
    if not assigned S`IsProductOfOrdersInFactorAlgebras then
        A:=Algebra(S);
        idem:=[ i : i in Idempotents(A) | i in S]; // idempotents in S
        output:=[PowerStructure(AlgEtQElt)|];
        if Seqset(idem) eq { One(A), Zero(A) } then
            S`IsProductOfOrdersInFactorAlgebras:=<false,output>;
        else
            test,D:=IsPowerOf(#idem,2);
            assert test;
            F2:=GF(2);
            V:=VectorSpace(F2,#Components(A));
            idem_inV:=[ V![ c eq 1 select F2!1 else F2!0 : c in Components(i) ] : i in idem ];
            arr:=AssociativeArray();
            for j in [1..#idem] do
                i:=idem[j];
                v:=idem_inV[j];
                n:=#[ x : x in Eltseq(v) | x eq 1 ];
                if not IsDefined(arr,n) then
                    arr[n]:=[];
                end if;
                Append(~arr[n],j);
            end for;
            max:=Max(Keys(arr));
            W:=sub<V|>;
            n:=1;
            while Dimension(W) lt D do
                if IsDefined(arr,n) then
                    for j in arr[n] do
                        v:=idem_inV[j];
                        if not v in W then 
                            Append(~output,idem[j]);
                            W:=sub<V| W,v>;
                            if Dimension(W) eq D then
                                break;
                            end if;
                        end if;
                    end for;
                end if;
                n+:=1;
            end while;
            assert #output eq D;
            assert OneIdeal(S) eq Ideal(S , [ z*g : z in ZBasis(S) , g in output ]);

            S`IsProductOfOrdersInFactorAlgebras:=<true, output>; 
        end if;
    end if;
    return Explode(S`IsProductOfOrdersInFactorAlgebras);
end intrinsic;

///# Example 3
/// ```
/// _<x>:=PolynomialRing(Integers());
/// // We consider the following three number fields
/// K1:=NumberField(x^2-2);
/// K2:=NumberField(x^2-3);
/// K3:=NumberField(x^2-5);
/// // We define the product étale algebra A and the factor algebras B and C consisting of only the first two components and the last one, repsectively.
/// B:=EtaleAlgebra([K1,K2]);
/// C:=EtaleAlgebra([K3]);
/// A,embs,projs:=DirectProduct([B,C]);
/// // The maximal order of A is the product of the three ring of integers.
/// OA:=MaximalOrder(A);
/// IsProductOfOrdersInComponents(OA);
/// // The equation order of A is not a product in any factor algebra
/// EA:=EquationOrder(A);
/// IsProductOfOrdersInFactorAlgebras(EA);
/// // Now we construct an order that is a product of an order in B and one in C, but does not admit further splittings.
/// a:=PrimitiveElement(A);
/// e1:=A![1,0,0];
/// e2:=A![0,1,1];
/// R:=Order([a*e1,a*e2]);
/// IsProductOfOrdersInFactorAlgebras(R);
/// ```

/* TESTS
    
    printf "### Testing Orders:";
	//AttachSpec("~/AlgEt/spec");
    SetVerbose("AlgEtQOrd",1);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    O1:=Order(Basis(A));
    _:=ZBasis(O1);
    _:=Generators(O1);
    O2:=Order(AbsoluteBasis(A) : Check:=0);
    O3:=Order(AbsoluteBasis(A));
    _:=O1 eq O2;
    _:=O2 eq O3;
    assert EquationOrder(A) ne ProductOfEquationOrders(A);
    printf ".";

    // we test KnownOrders
    OA:=MaximalOrder(A);
    O:=Order(ZBasis(OA));
    assert assigned O`IsMaximal; //at creation O<-OA since we call IsKnownOrder
    assert O eq OA;
    printf ".";

    ff:=Conductor(EquationOrder(A));
    T:=MultiplicatorRing(ff);
    assert T in A`KnownOrders[Index(T)];
    assert assigned T`IsMaximal and assigned T`IsProductOfOrders; //these two attributes are assigned when we created OA above.
                                                                  // hence T points to the same memory spot of OA
    printf ".";

    O:=Order(ZBasis(OA));
    assert IsProductOfOrders(O);
    assert IsMaximal(O);
    printf ".";

    O:=MaximalOrder(A);
    G:=[[ Random(O) : i in [1..3] ] : i in [1..100]];
    S:=[ Order(s) : s in G ];
    _:=#Seqset(S);
    printf ".";

    assert forall{z : z in ZBasis(O1) | z in O1 };
    for O in [O1,O2,O3] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;
    printf ".";

    seq:=[x^2-5*25,x^2-7*49];
    seq:=[NumberField(f) : f in seq];
    A:=EtaleAlgebra(seq);
    O1:=Order(Basis(A));
    O2:=Order(AbsoluteBasis(A));
    assert O1 eq O2;
    for O in [O1,O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;
    printf ".";

    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    E3:=Order(A,<EquationOrder(seq[1]) , MaximalOrder(seq[2])>);
    E4:=Order(A,<MaximalOrder(seq[1]) , EquationOrder(seq[2])>);
    OA:=MaximalOrder(A);
    for E in [E1,E2,E3,E4] do 
        _:=Index(OA,E);
    end for;
    assert E1 subset E2;
    assert E1 subset E3;
    assert E3*E4 eq OA;
    assert OA meet E1 eq E1;
    assert not E2 meet E1 eq E2;

    SetAssertions(1);
    printf "all good!";
*/