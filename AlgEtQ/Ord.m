/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Functions for order in Etale Q algebras
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtQOrd, 3;

/*TODO:
*/


declare type AlgEtQOrd;

declare attributes AlgEtQ : MaximalOrder,
                           ProductOfEquationOrders,
                           EquationOrder,
                           KnownOrders; // This is a AssociativeArray indexed by rational numbers q:
                                        // in the key q we store all orders S in the algebra such that q=Index(S),
                                        // which is the index with respect to the fixed basis of A.
                                        // We store them, because to avoid creating multiple copies of the same order.
                                        // In particular, this is more efficient for the attributes.
                                        // The attribute is populated by the following intrinsics: 
                                        // ComplexConjugate, MultiplicatorRing, EquationOrder, ProductOfEquationOrders, 
                                        // MaximalOrder, FindOverOrders, MinimalOverOrders, LoadWKICM

declare attributes AlgEtQOrd : IsMaximal,
                              IsProductOfOrders,
                              Index,
                              ZBasis,
                              Generators,
                              OneIdeal,
                              Algebra,
                              TraceDualIdeal,
                              Conductor,
                              IsGorenstein,
                              IsBass,
                              Hash,
                              inclusion_matrix;

//----------
// Basics
//----------

intrinsic Print(A::AlgEtQOrd)
{Print the order.}
  printf"Order in %o", A`Algebra;
end intrinsic;

intrinsic IsCoercible(S::AlgEtQOrd, x::.) -> BoolElt, Any
{Return whether x is coercible into S and the result if so.}
    bool,x:=IsCoercible(Algebra(S),x);
    if bool and x in S then
        return true,x;
    else
        return false,_;
    end if;
end intrinsic;

//----------
// Auxiliary functions
//----------

crZQ:=function(M)
//given a matrix M over the Integers() changes the base ring to Rationals()
    return ChangeRing(M,Rationals());
end function;

crQZ:=function(M)
//given a matrix M over the Rationals() changes the base ring to Integers()
    return ChangeRing(M,Integers());
end function;

Columns:=function(M)
    return Rows(Transpose(M));
end function;

hnf:=function(M)
//input: a matrix over the Integers() 
//output: the matrix in HNF
    N:=Rank(M);
    H:=HermiteForm(M);
    H:=Matrix(Rows(H)[1..N]);
    return H;
end function;

MatrixAtoQ:=function(gens)
//input:  a sequence of elements of an AlgEtQ A
//output: a matrix over Rationals() whose coordinates are the AbsoluteCoordinates of gens
    return Matrix([AbsoluteCoordinates(g) : g in gens]);
end function;

MatrixAtoZ:=function(gens)
//return a matrix with integers entries which rows the elements of gens
    return crQZ(MatrixAtoQ(gens));
end function;

MatrixQtoA:=function(A,P)
//given a matrix with Integer or Rational entries, returns a sequence of elements of A, corresponding to the rows.
    abs:=AbsoluteBasis(A);
    abs_dim:=AbsoluteDimension(A);
    N:=#Components(A);
    rows:=[ Eltseq(r) : r in Rows(P)];
    Nrow:=#rows;
    assert #Columns(P) eq abs_dim;
    // we first do the operations componentwise, and then create the element of A
    // in this way we save many calls of IsCoercible
    out_new:=<>;
    for j in [1..N] do
        Append(~out_new,[ &+[r[i]*Components(abs[i])[j] : i in [1..abs_dim]] : r in rows]);
    end for;
    out:= [ A!<out_new[j][r] : j in [1..N]> : r in [1..Nrow] ]; 
    return out;
end function;

//----------
// Creation
//----------

intrinsic Order( gens::SeqEnum[AlgEtQElt] : Check:=100 ) -> AlgEtQOrd
{Construnct the order generated by gens over the rationals. The parameter Check (default 100) determines how many times the program tries to obtain a multiplicatively closed lattice by adding the product of the generators. If Check 0 then this step is skipped.}
    A:=Universe(gens);
    gens:=Setseq(Seqset(gens));// we remove duplicates
    dim:=AbsoluteDimension(A);
    R:=New(AlgEtQOrd);
    R`Algebra:=A;
    require forall{g : g in gens | IsIntegral(g) } : "The elements are not all integral, hence do not generate an order.";
    if Check gt 0 then 
        gens0:=gens;
        if not One(A) in gens then
            gens0:=[One(A)] cat gens0;
        end if;
        M:=MatrixAtoQ(gens0);
        d:=Denominator(M);
        P:=crZQ(hnf(crQZ(d*M)))/d;
        gens0:=MatrixQtoA(A,P);
        fail:=0;
        repeat
            P_old:=P;
            gens0 cat:= [(g1*g2) : g1,g2 in gens0];
            M:=MatrixAtoQ(gens0);
            d:=Denominator(M);
            M:=crQZ(M*d);
            P:=crZQ(hnf(M))/d;
            gens0:=MatrixQtoA(A,P);
            fail +:=1;
            go:=Rank(P_old) eq dim and P eq P_old;
        until go or fail gt Check;
        if fail gt Check then 
            error "The program could not generate a multiplicatively closed set from the given generators. Try to increase the value of Check, or choose different generators.";
        end if;
        d:=Denominator(P); //this d might be different from Denomintor(M)
        R`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        // UNSAFE R`Hash:=Hash(P);
        zb:=MatrixQtoA(A,P);
    else
    //we assume that gens is a ZBasis of a multiplicativly closed lattice
        zb:=gens;
    end if;

    assert #zb eq dim;
    if #gens le dim then
        R`Generators:=gens;
    else
        R`Generators:=zb;
    end if;
        R`ZBasis:=zb;
    assert2 One(A) in R;
    return R;
end intrinsic;

intrinsic Order(A::AlgEtQ , orders::Tup) -> AlgEtQOrd
{Given a sequence of order in the number fiedls defining the etale algebra A, generates the product order.}
    nf,embs,projs:=Components(A);
    require #nf eq #orders and forall{ i : i in [1..#orders] | NumberField(orders[i]) eq nf[i]} and 
forall{ S : S in orders | Type(S) eq RngOrd } : "The second input should be a sequence of orders in the number fields defining A";
    gens:=&cat[ [ embs[i](z) : z in AbsoluteBasis(orders[i]) ] : i in [1..#nf] ];
    O:=Order(gens : Check:=0); // the gens given generate a multiplicatively closed lattice in A
    assert2 O eq Order(gens);
    O`IsProductOfOrders:=<true,orders>;
    return O;
end intrinsic;

intrinsic OrderOver( gens::SeqEnum[AlgEtQElt] , S::RngOrd : Check:=100 ) -> AlgEtQOrd
{Given elements gens from an etale algebra A over a base field F and an order S in F, returns the order in A generated by gens over S. The parameter Check (default <true,100>) determines whether the programs checks if gens create a multiplicatively closed lattice, and if not adds elements until it is so, for Check[2] times.}
    A:=Universe(gens);
    F,mFA:=BaseField(A);
    require NumberField(S) eq F : "The base order does not lie in the bse field.";
    bOFinA:=[ mFA(b) : b in Basis(S)];
    gens:=[ g * b : g in gens, b in bOFinA ];
    return Order( gens : Check:=Check );
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(S::AlgEtQOrd) -> AlgEtQ
{Returns the algebra of the order.}
  return S`Algebra;
end intrinsic;

intrinsic myHash(S::AlgEtQOrd)->SeqEnum[RngInt]
{Hash function for AlgEtQOrd.}
// two orders have the hash iff they are equal
    if not assigned S`Hash then
        /* OLD
        P:=MatrixAtoQ(ZBasis(S));
        d:=Denominator(P);
        P:=crZQ(hnf(crQZ(d*P)))/d;
        */
        M:=MatrixAtoQ(ZBasis(S));
        d:=Denominator(M);
        M:=crQZ(M*d);
        P:=crZQ(hnf(M))/d;
        assert2 IsUpperTriangular(P);
        // UNSAFE S`Hash:=Hash(P);
        dim:=AbsoluteDimension(Algebra(S));
        d:=Denominator(P); //this d might be different from Denomintor(M)
        S`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
    end if;
    return S`Hash;
end intrinsic;

intrinsic ZBasis(S::AlgEtQOrd)->SeqEnum[AlgEtQElt]
{Return a Z-basis of the order.}    
    // assigned at creation
    return S`ZBasis;
end intrinsic;

intrinsic Generators(S::AlgEtQOrd)->SeqEnum[AlgEtQElt]
{Return a set of generators of the order.}    
    // assigned at creation
    return S`Generators;
end intrinsic;

//----------
// Equality
//----------

intrinsic 'eq'(O1::AlgEtQOrd,O2::AlgEtQOrd)->BoolElt
{Checks equality of orders in an etale Algebra.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same etale algebra";
    if 
    //O1`Generators eq O2`Generators or O1`ZBasis eq O2`ZBasis or //this seems to be slowe
    myHash(O1) eq myHash(O2) then 
        out:=true;
    else
        out:=false;
    end if;
    vprintf AlgEtQOrd,3 : "output of equality = %o\n",out;
    /* There is an issue here: certain attributes are depend on others. For example we cannot pass the inclusion_matrix and not the ZBasis, since the first depends on the second.
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtQOrd) do
            if assigned O1``att and not assigned O2``att then
                O2``att:=O1``att;
            elif assigned O2``att and not assigned O1``att then
                O1``att:=O2``att;
            end if;
        end for;
    end if;
    */
    return out;
end intrinsic;

//----------
// Inclusion
//----------

inclusion_matrix:=function(O)
// the inclusion matrix is simply the inverse of the matrix MatrixAtoQ(ZBasis(O)).
// This allows to check if an element is in O by simply making one matrix multiplication, rather then
// solving a system (as in AbsoluteCoordinates). It is much faster.
// O can also be an ideal.
    if not assigned O`inclusion_matrix then
        O`inclusion_matrix:=MatrixAtoQ(ZBasis(O))^-1; 
    end if;
    return O`inclusion_matrix;
end function;

intrinsic 'in'(x::AlgEtQElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of elements.} 
    require Algebra(x) cmpeq Algebra(O) : "the algebra is not the same";
    /* //this check succeeds very rarely, and makes the code a bit slower.
    if (assigned O`Generators and x in O`Generators)
        or (assigned O`ZBasis and x in O`ZBasis) then
        return true;
    end if;
    */
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],O)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtQElt],O::AlgEtQOrd) -> SeqEnum
{AbsoluteCoordinates with respect to the ZBasis.}
    require forall{ x : x in seq | Algebra(x) cmpeq Algebra(O)} : "the algebra is not the same";
    Minv:=inclusion_matrix(O);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::RngIntElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of elements.}
    return (Algebra(O)!x) in O;
end intrinsic;

intrinsic 'in'(x::FldRatElt,O::AlgEtQOrd) -> BoolElt
{Inclusion of elements.} 
    return (Algebra(O)!x) in O;
end intrinsic;

//----------
// Elements in orders
//----------

intrinsic One(S::AlgEtQOrd)->AlgEtQElt
{Unit element of S.}
    A:=Algebra(S);
    return One(A);
end intrinsic;

intrinsic Zero(S::AlgEtQOrd)->AlgEtQElt
{Zero element of S.}
    A:=Algebra(S);
    return Zero(A);
end intrinsic;

intrinsic Random(O::AlgEtQOrd , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Random element of O. The Coefficients are bounded by the positive integer bd. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false.}
    require bd gt 0 : "The bound needs to be a positive integer.";
    ZBasisLLL(O); // to keep the element small.
    B := ZBasis(O);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic Random(O::AlgEtQOrd : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtQElt
{Returns a random (small coefficient) element of O. The range of the random coefficients can be increased by giving the optional argument CoeffRange. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false.}
      return Random(O,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;


//----------
// IsKnownOrder
//----------

intrinsic IsKnownOrder(~R::AlgEtQOrd)
{This procedure checks wheter the order R is already in the list of known orders of the algebra A of definition of R. If so then it replaces R with the copy stored in the attribute KnownOrders. If not it adds it to KnownOrders. This is done to avoid creating multiple copies of the same order.}
    A:=Algebra(R);
    /* OLD
    if not assigned A`KnownOrders then
        A`KnownOrders:={@ @};
    end if;
    if exists(S){ T : T in A`KnownOrders | R eq T } then
        R:=S;
    else
        Include(~A`KnownOrders,R);
    end if;
    */
    // new with AssociativeArray. Sorting the orders, should make it faster.
    if not assigned A`KnownOrders then
        A`KnownOrders:=AssociativeArray();
        A`KnownOrders[Index(R)]:={@ R @};
    else
        ind:=Index(R);
        if not IsDefined(A`KnownOrders,ind) then
            A`KnownOrders[ind]:={@ R @};
        else
            if exists(S){ T : T in A`KnownOrders[ind] | R eq T } then // this equality is done on the Hash level,
                                                                      // which means that 
                R:=S;
            else
                Include(~A`KnownOrders[ind],R);
            end if;
        end if;
    end if;
end intrinsic;

//----------
// Equation Orders
//----------

intrinsic EquationOrder(A::AlgEtQ) -> AlgEtQOrd
{Given an étale algebra defined by a polynomial, returns the monogenic order defined by the same polynomial.}
    if not assigned A`EquationOrder then
        require PrimeField(A) eq BaseField(A) : "Defined only for algebras over the Rationals()";
        pow:=PowerBasis(A);
        E:=Order(pow : Check:=0); //the PowerBasis genertes a mutliplicativelyclosed lattice
        assert2 E eq Order([pow[2]]);
        E`Generators:=[pow[2]]; // I want the genertor set to be small, so I put only the primitive element
        A`EquationOrder:=E;
        IsKnownOrder(~E); // the order was not already known. this call caches it in A`KnownOrders
    end if;
    return A`EquationOrder;
end intrinsic;

intrinsic ProductOfEquationOrders(A::AlgEtQ)->AlgEtQOrd
{Given a product of number field A, returns the order consisting of the product of the equation orders of the number fields.}
    if not assigned A`ProductOfEquationOrders then
        E:=Order( A , <EquationOrder(E) : E in Components(A)> );
        A`ProductOfEquationOrders := E;
        IsKnownOrder(~E); // the order was not already known. this call caches it in A`KnownOrders
    end if;
    return A`ProductOfEquationOrders ;
end intrinsic;

//----------
// Maximal Order
//----------

intrinsic MaximalOrder(A::AlgEtQ)->AlgEtQOrd
{Returns the maximal order of the étale algebra A.}
    if not assigned A`MaximalOrder then    
        O:=Order( A , <MaximalOrder(E) : E in Components(A)> );
        ZBasisLLL(O);
        O`IsMaximal:=true;
        A`MaximalOrder:=O;
        IsKnownOrder(~O); // the order was not already known. this call caches it in A`KnownOrders
    end if;
    return A`MaximalOrder;
end intrinsic;

intrinsic IsMaximal(S::AlgEtQOrd) -> BoolElt
{Returns wheter the given order is the maximal order of the étale algebra.}
    if not assigned S`IsMaximal then
        O:=MaximalOrder(Algebra(S));
        S`IsMaximal:=S eq O;
    end if;
    return S`IsMaximal;
end intrinsic;

//----------
// IsProduct
//----------

intrinsic IsProductOfOrders(O::AlgEtQOrd)->BoolElt, Tup
{Return if the argument is a product of orders in number fields, and if so return also the sequence of these orders.}
    if not assigned O`IsProductOfOrders then
        A:=Algebra(O);
        idem:=OrthogonalIdempotents(A);
        test:=forall{x : x in idem | x in O};
        if test then
            nf,_,projs:=Components(A); 
            if #nf eq 1 then
                orders:=< Order([ projs[1](z) : z in ZBasis(O) ])  >;
            else
                zb:=ZBasis(O);
                require PrimeField(A) eq BaseField(A) : "We require the algebra to be defined over the Rationals(). The reason is that we don't have a functioning method to create orders in relative number fields which are not over the maximal order of the base field. One can still check if the order O is a product by cehcking if OrthogonalIdempotents(A) are in O."; 
                orders:=< Order( [ projs[i](z) : z in zb ] ) : i in [1..#idem] >;
                assert2 O eq Order(A,orders);
            end if;
            O`IsProductOfOrders:=<true,orders>;
        else
            O`IsProductOfOrders:=<false,<>>;
        end if;
    end if;
    return Explode(O`IsProductOfOrders);
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtQOrd) -> FldRatElt
{Given an order T computes its index with respect to the basis of the algebra of T as a free Z-module.}
  if not assigned T`Index then
    matT:=MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(S::AlgEtQOrd, T::AlgEtQOrd) -> Any
{Given two orders T \subset S, returns [S:T] = #S/T.}
  assert Algebra(T) cmpeq Algebra(S);
  elt := Index(T)/Index(S);
  if IsCoercible(Integers(), elt) then
    elt := Integers() ! elt;
  end if;
  return elt;
end intrinsic;

//----------
// Subset and product of orders
//----------

intrinsic 'subset'(O1 :: AlgEtQOrd, O2 :: AlgEtQOrd) -> BoolElt
{Checks if the first argument is inside the second.}
  require Algebra(O1) cmpeq Algebra(O2) : "The orders must be in the same algebra.";
  if not Index(O2, O1) in Integers() then
    return false;
  end if;
  return forall{z : z in Generators(O1) | z in O2 };
end intrinsic;

intrinsic '*'(O1::AlgEtQOrd,O2::AlgEtQOrd)->AlgEtQOrd
{Returns the order generated by the orders O1 and O2.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if O1 eq O2 then
        return O1;
    end if;
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O1;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O2;
    end if;
    if O1 subset O2 then
        return O2;
    end if;
    if O2 subset O1 then
        return O1;
    end if;
    gens:=Setseq( Seqset(Generators(O1) cat Generators(O2)) );
    return Order(gens);
end intrinsic;

//----------
// Intersection
//----------

meet_zbasis:=function(zb1,zb2)
//Returns the ZBasis of the intersection of the lattices gerated by the gven two Z-bases.
    A:=Algebra(zb1[1]);
    N:=#zb1;
    MI:=crZQ(MatrixAtoQ(zb1));
    MJ:=crZQ(MatrixAtoQ(zb2));
    dI:=Integers() ! Denominator(MI);
    dJ:=Integers() ! Denominator(MJ);
    d:=LCM(dI,dJ);
    MI:=crQZ(d*MI);
    MJ:=crQZ(d*MJ);
    MZ:=ZeroMatrix(Integers(),N,N);
    M:=Matrix(HorizontalJoin(VerticalJoin(MI,MJ),VerticalJoin(MI,MZ)));
    M:=hnf(M);
    //the hnf of zb1 meet zb2 is the lower-right quadrant of M
    P:=Matrix(N,N,[M[i,j] : i,j in [N+1..2*N]]);
    P:=(1/d)*crZQ(P);
    zb:=MatrixQtoA(A,P);
    return zb;
end function;


intrinsic 'meet'(O1::AlgEtQOrd,O2::AlgEtQOrd)->AlgEtQOrd
{Intersection of orders.}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O2;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O1;
    end if;
    if O1 eq O2 then
        return O1;
    end if;
    if O1 subset O2 then
        return O1;
    end if;
    if O2 subset O1 then
        return O2;
    end if;
    zb:=meet_zbasis(ZBasis(O1),ZBasis(O2));
    O:=Order(zb : Check:=0 ); //the intersecion of two orders is multiplicatively closed
    assert2 O eq Order(zb);
    return O;
end intrinsic;

//----------
// Others
//----------

intrinsic MultiplicatorRing(R::AlgEtQOrd) -> AlgEtQOrd
{Returns the multiplicator ring of an order R, that is R itself.}
    return R;
end intrinsic;

/* TESTS
    
    printf "### Testing Orders:";
	AttachSpec("~/packages_github/AlgEt/spec");
    SetVerbose("AlgEtQOrd",1);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    O1:=Order(Basis(A));
    _:=ZBasis(O1);
    _:=Generators(O1);
    O2:=Order(AbsoluteBasis(A) : Check:=0);
    O3:=Order(AbsoluteBasis(A));
    _:=O1 eq O2;
    _:=O2 eq O3;
    assert EquationOrder(A) ne ProductOfEquationOrders(A);
    printf ".";

    // we test KnownOrders
    OA:=MaximalOrder(A);
    O:=Order(ZBasis(OA));
    assert not assigned O`IsMaximal;
    assert O eq OA;
    assert not assigned O`IsMaximal; //not passing attributes at equality checks
    IsKnownOrder(~O); //now we known that O eq OA
    assert assigned O`IsMaximal;
    printf ".";

    ff:=Conductor(EquationOrder(A));
    T:=MultiplicatorRing(ff);
    assert T in A`KnownOrders[Index(T)];
    assert assigned T`IsMaximal and assigned T`IsProductOfOrders; //these two attributes are assigned when we created OA above.
                                                                  // hence T points to the same memory spot of OA
    printf ".";


    O:=Order(ZBasis(OA));
    assert IsProductOfOrders(O);
    assert IsMaximal(O);
    printf ".";

    O:=MaximalOrder(A);
    G:=[[ Random(O) : i in [1..3] ] : i in [1..100]];
    S:=[ Order(s) : s in G ];
    _:=#Seqset(S);
    printf ".";

    assert forall{z : z in ZBasis(O1) | z in O1 };
    for O in [O1,O2,O3] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;
    printf ".";

    seq:=[x^2-5*25,x^2-7*49];
    seq:=[NumberField(f) : f in seq];
    A:=EtaleAlgebra(seq);
    O1:=Order(Basis(A));
    O2:=Order(AbsoluteBasis(A));
    assert O1 eq O2;
    for O in [O1,O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;
    printf ".";

    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    E3:=Order(A,<EquationOrder(seq[1]) , MaximalOrder(seq[2])>);
    E4:=Order(A,<MaximalOrder(seq[1]) , EquationOrder(seq[2])>);
    OA:=MaximalOrder(A);
    for E in [E1,E2,E3,E4] do 
        _:=Index(OA,E);
    end for;
    assert E1 subset E2;
    assert E1 subset E3;
    assert E3*E4 eq OA;
    assert OA meet E1 eq E1;
    assert not E2 meet E1 eq E2;
    assert E3 meet E4 eq E2;
    O:=MaximalOrder(A);

    printf " all good!\n"; 

*/

