/* vim: set syntax=magma :*/

/////////////////////////////////////////////////////
// Stefano Marseglia, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
// 
// Distributed under the terms of the GNU Lesser General Public License (L-GPL)
//      http://www.gnu.org/licenses/
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 3.0 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
// 
// Copyright 2024, S. Marseglia
/////////////////////////////////////////////////////

freeze;

declare verbose AlgEtQMod, 3;

/*TODO:

*/

declare type AlgEtQMod;
declare attributes AlgEtQMod : Index, //stores the index
                              Order, // an order R
                              UniverseAlgebra, // A pair <V,m> where V is the algebra where M lives in, and m is the action Algebra(R)->V
                              Generators,
                              ZBasis,
                              IsDirectSumOfIdeals,
                              Hash,
                              inclusion_matrix;

import "../AlgEtQ/Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;
import "PowerBass.m" : is_pure_power_internal;

/*TODO
*/

//----------
// Creation functions
//----------

CreateAlgEtQMod:=function(S,m,gens)
// Given S::AlgEtQOrd and some generateors creates the new object 
// m:Algebra(S)->Parent(gens[1]) determine the action
// Here we just assign the generators. we do not compute the Zbasis unless necessary!
    I:=New(AlgEtQMod);
    V:=Codomain(m);
    I`UniverseAlgebra:=<V,m>;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(V) then
        ZZ:=Integers();
        vprintf AlgEtQIdl,3: "too many gens";
        gens:=[g*m(s) : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    return I;
end function;

intrinsic Module(S::AlgEtQOrd, m::Map, gens::SeqEnum) -> AlgEtQMod
{Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.}
    V:=Codomain(m);
    gensV:=[];
    for g in gens do
        bool,gV:=IsCoercible(V,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensV,gV);
    end for;
    return CreateAlgEtQMod(S,m,gensV);
end intrinsic;

intrinsic Module(S::AlgEtQOrd,m::Map,idls::Tup) -> AlgEtQMod
{Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in Components(V), returns the sub-S-module of V generated by the direct sum of the ideals.}
    K:=Algebra(S);
    V:=Codomain(m);
    Vnf,Ve:=Components(V);
    require #Vnf eq #idls and forall{ i : i in [1..#idls] | NumberField(Order(idls[i])) cmpeq Vnf[i]} : "The ideals do not generate an S-module in V.";
    gens:=&cat[ [Ve[i](z) : z in Basis(idls[i]) ] : i in [1..#Vnf]];
    I:=Module(S,m,gens);
    // note: I is generated by a direct sum, but might not be a direct sum.
    return I;
end intrinsic;

intrinsic ModuleFromDirectSum(R::AlgEtQOrd,m::Map,seq::SeqEnum[Tup])->AlgEtQMod
{Let K and V be AlgEtQ such that m:K->V is a K-module. Let R be an order and a map m:Algebra(R)->A, where A is an algebra isomorphic to Algebra(R)^s. Let seq be a sequence of pairs <J,v> where J is a fractional R ideal and v is either an element of A or a map v:Algebra(J)->A. It returns the AlgEtQMod M=J1v1+J2v2+...Jsvs (in the first case) or J1v1(1)+...+Jsvs(1) (in the second case).}
    is_pure_power,ones:=is_pure_power_internal(m);
    require is_pure_power : "The universe algebra is not of the form K^r";
    AR:=Algebra(R);
    UA:=Codomain(m);
    assert m(One(AR)) eq One(UA);
    require AR eq Domain(m) : "the map does not have Algebra(R) as codomain";
    require forall{I : I in seq | Order(I[1]) eq R } : "the fractional ideals are not R ideals";
    if forall{I : I in seq | Type(I[2]) eq Map } then
        require forall{I : I in seq | Domain(I[2]) eq AR and Codomain(I[2]) eq UA } : "the sequence is not valid for this constructor";
        //in this case the given seq is the DirectSumRep of the module
        gens:=&cat[ [ I[2](z) : z in ZBasis(I[1]) ] : I in seq ];
        dsr:=seq;
    elif forall{I : I in seq | Type(I[2]) eq AlgEtQElt } then 
        require forall{I : I in seq | Parent(I[2]) eq UA } : "the sequence is not valid for this constructor";
        dsr:=[];
        gens:=[];
        basisAR:=AbsoluteBasis(AR);
        for I in seq do 
            mI:=Hom(AR,UA,[m(basisAR[i])*I[2] : i in [1..Dimension(AR)] ] : ComputeInverse:=false);  //map that sends one to I[2] 
            Append(~dsr,<I,mI>);
            gens cat:=[ mI(z) : z in ZBasis(I[1]) ];
        end for;
    else
        error "the sequence is not valid for this constructor";
    end if;
    require Dimension(UA) eq Rank(MatrixAtoQ(gens)) : "gens do not generater a Z-module of full rank";
    M:=Module(R,m,gens);
    return M;
end intrinsic;

intrinsic Print(I::AlgEtQMod)
{Prints the module.}
  printf"Module over %o", Order(I);
end intrinsic;

//----------
// Natural Action
//----------

intrinsic NaturalAction(K::AlgEtQ, V::AlgEtQ)->Map
{Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.}
    Knf:=[ DefiningPolynomial(L) : L in Components(K) ];
    Vnf:=[ DefiningPolynomial(L) : L in Components(V) ];
    require #Seqset(Knf) eq #Components(K) : "The number fields defining K are not distinct";
    require Seqset(Knf) eq Seqset(Vnf) : "There is no componentwise diagonal action of K on V";
    ind:=[ Index(Knf,fV) : fV in Vnf]; // there is only one index in Knf for each fV since Knf is a product of distinct number fields
    mKV:=function(x)
        cx:=Components(x);
        y:=< cx[ind[i]] : i in  [1..#Vnf]>;
        return y;
    end function;
    m:=map< K->V | x:->mKV(x)>;
    return m;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic UniverseAlgebra(I::AlgEtQMod) -> AlgEtQ,Map
{Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).}
    return Explode(I`UniverseAlgebra);
end intrinsic;

intrinsic Order(I::AlgEtQMod) -> AlgEtQOrd
{Returns the order of definition of the module.}
    return I`Order;
end intrinsic;

intrinsic Generators(I::AlgEtQMod) -> SeqEnum[AlgEtQElt]
{Returns the generators of the module.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(UniverseAlgebra(I));
    return I`Generators;
end intrinsic;

intrinsic ZBasis(I::AlgEtQMod)->SeqEnum[AlgEtQElt]
{Returns a Z-basis of the module.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        V,m:=UniverseAlgebra(I);
        S:=Order(I);
        gens:=[g*m(s) : g in Generators(I) , s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Integers()!Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic myHash(I::AlgEtQMod)->RngInt
{Hash function.}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(UniverseAlgebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Inclusion and equality
//----------

intrinsic 'eq'(I::AlgEtQMod,J::AlgEtQMod) -> BoolElt
{Equality testing.}
    V,m:=UniverseAlgebra(I);
    VJ,mJ:=UniverseAlgebra(I); 
    require V cmpeq VJ : "The modules are not in the same algebra.";
    // one should check that the action is the same, maybe with an assert2
    require Order(I) cmpeq Order(J) : "The modules are not over the same order.";
    out:=myHash(I) eq myHash(J);
    // if out then //we copy the attributes
    //     for att in GetAttributes(AlgEtQIdl) do
    //         if assigned I``att and not assigned J``att then
    //             J``att:=I``att;
    //         elif assigned J``att and not assigned I``att then
    //             I``att:=J``att;
    //         end if;
    //     end for;
    // end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtQMod , J::AlgEtQMod ) -> BoolElt
{Disequality testing.}
    return not I eq J;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtQElt],I::AlgEtQMod) -> SeqEnum
{AbsoluteCoordiantes with respect to the ZBasis.} 
    require forall{x : x in seq | Algebra(x) cmpeq UniverseAlgebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtQElt , I::AlgEtQMod ) -> BoolElt
{Returns if x is in I.}
    require Algebra(x) eq UniverseAlgebra(I) : "the elements must lie in the same algebra of definition";
    // if assigned I`Generators and x in I`Generators then 
    //     return true;
    // end if;
    // if assigned I`ZBasis and x in I`ZBasis then 
    //     return true;
    // end if;
    // mat := AbsoluteCoordinates([x], ZBasis(I))[1];
    // return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt , I::AlgEtQMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'in'(x::FldRatElt , I::AlgEtQMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtQMod, I2 :: AlgEtQMod) -> BoolElt
{Checks if the first argument is inside the second.}
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtQMod) -> FldRatElt
{Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.}
  if not assigned T`Index then
    matT := MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtQMod, I::AlgEtQMod) -> Any
{Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].}
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;


//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtQOrd,I::AlgEtQMod) -> AlgEtQMod
{Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I.}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        _,m:=UniverseAlgebra(I);
        id:=Module(T,m,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        return id;
    else //in this case Order(I) is strictly contained in T
        _,m:=UniverseAlgebra(I);
        out:=Module(T,m,Generators(I));
        return out;
    end if;
end intrinsic;

//----------
// Quotients
//----------

intrinsic Quotient(I::AlgEtQMod, J::AlgEtQMod) -> GrpAb, Map
{Given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J.} 
    // if J is not inside I, an error occurs while forming Q. so no need to check in advance
    A:=UniverseAlgebra(I);
    zbI := ZBasis(I);
    N := #zbI;
    F := FreeAbelianGroup(N);
    rel := [F ! cc : cc in AbsoluteCoordinates(ZBasis(J),I)]; //using inclusion_matrix. Fast!
    //mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
    mFI := map<F->A| x:->SumOfProducts(Eltseq(x),zbI)>;
    mIF := map<A->F| x:-> F ! AbsoluteCoordinates([x],I)[1]>;
    Q,qFQ := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
   q:=map< A->Q | x:->qFQ(mIF(x)) , y:-> mFI(y@@qFQ) >; 
   return Q,q;
end intrinsic;


/* TESTS
    // see all_tests_AlgEtQMod.m
*/
