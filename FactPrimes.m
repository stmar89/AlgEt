/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose FactPrimes, 3;

/*TODO:

*/

//----------
// Factorization and Prime
//----------

function factorizationMaximalOrder(I)
//given an ideal of the maximal order of an Ã©tale algebra, returns the factorization into a product of prime ideals
    O:=Order(I);
    assert IsMaximal(O);
    A:=Algebra(O);
    test,IasProd:=IsProductOfIdeals(I);
    assert test;
    fac:=[]; //this will be the factorization of I
    nf,embs:=NumberFields(A);
    for i in [1..#nf] do
        IL:=IasProd[i];
        facL:=Factorization(IL); // < <P,e> : ... >;



        L:=A`NumberFields[i,1];
        mL:=A`NumberFields[i,2];
        assert IsMaximal(Order(IL));
        for p in facL do
            genPinA:=[mL(x) : x in Basis(p[1],L)] cat [F[2](One(F[1])) : F in A`NumberFields | F[1] ne L];
            P:=Ideal(O,genPinA);
            assert2 IsPrimePower(Integers() ! Index(O,P));
            Append(~fac,<P,p[2]>);
        end for;
    end for;
    assert2 I eq &*[p[1]^p[2] : p in fac];
    return fac;
end function;

intrinsic Factorization(I::AlgEtIdl) -> Tup
{given a proper integral S-ideal I coprime with the conductor of S (hence invertible in S), returns its factorization into a product of primes of S}
    S:=Order(I);
    require IsIntegral(I) and I ne OneIdeal(S): "the argument must be a proper integral ideal";
    if not assigned I`Factorization then    
        if IsMaximal(S) then
        I`Factorization:=factorizationMaximalOrder(I);
        else
            fS:=Conductor(S);
            require IsCoprime(fS,I): "the ideal must be coprime with the conductor of the order of definition";
            O:=MaximalOrder(Algebra(I));
            IO:=O !! I;
            facO:=factorizationMaximalOrder(IO);
            primesO:=[ p[1] : p in facO ];
            primesS:=Setseq({ OneIdeal(S) meet (S!!PO) : PO in primesO }); //this should cancel the doubles
            facS:=<>;
            for i in [1..#primesS] do
                P:=primesS[i];
                P`IsPrime:=true;
                expP:=&+([ pO[2] : pO in facO | (S meet (S!!pO[1])) eq P ]);
                Append(~facS, <P,expP>);
            end for;
            assert2 I eq &*([ p[1]^p[2] : p in facS ]);
            I`Factorization:=facS;
        end if;
     end if;
     return I`Factorization;
end intrinsic;

intrinsic PrimesAbove(I::AlgEtIdl) -> SeqEnum[AlgAssEtOrdIdl]
{given an integral S-ideal, returns the sequence of maximal ideals P of S above I}
    require IsIntegral(I): "the ideal must be integral";
    if not assigned I`PrimesAbove then
        if assigned I`Factorization then
            primes:=[P[1] : P in I`Factorization];
        end if;
        S:=Order(I);
        if I eq OneIdeal(S) then
            primes:=[];
        else
            if IsMaximal(S) then
                O:=S;
                IO:=I;
            else
                O:=MaximalOrder(Algebra(I));
                IO:=O!!I;
            end if;
            fac:=Factorization(IO);
            primes:= Setseq({ OneIdeal(S) meet (S!!PO[1]) : PO in fac });
            assert2 forall{P : P in primes | IsIntegral(P)};
            assert2 forall{P : P in primes | Index(S,P) gt 1};
            for i in [1..#primes] do
                P:=primes[i];
                P`IsPrime:=true;
            end for;
            assert2 forall{P : P in primes | I subset P};
            assert2 forall{P : P in primes | IsPrimePower(Integers() ! Index(S,P))};
        end if;
        I`PrimesAbove:=primes;
    end if;
    return I`PrimesAbove;
end intrinsic;

intrinsic IsPrime(I::AlgEtIdl) -> BoolElt
{given an integral S-ideal, returns if the ideal is a prime fractional ideal of S, that is a maximal S ideal}
    require IsIntegral(I): "the ideal must be integral";
    if not assigned I`IsPrime then
        prim:=PrimesAbove(I);
        if #prim eq 1 and I eq prim[1] then
            bool:=true;
        else
            bool:=false;
        end if;
        I`IsPrime:=bool;
    end if;
    return I`IsPrime;
end intrinsic;

intrinsic IsBass(S::AlgEtOrd) -> BoolElt
{check if the order is Bass}
// we compute the maximal order O and check if O/PO is at most 2-dimensional over S/P for every singular prime P
// This coincides with the usual definition since O has the maximal number of generators as a fractional S ideal and S is Bass iff every ideal can be generated by at most 2-elements.
// see Hofman,Sircana, On the computations of over-orders, Definition 5.23
    if IsMaximal(S) then 
        return true;
    else
        O:=MaximalOrder(Algebra(S));
        ff:=Conductor(S);
        sing:=PrimesAbove(ff);
        for P in sing do
            k:=Integers() ! Index(S,P);
            OS:=Ideal(S,ZBasis(O));
            N:=Integers() ! Index(OS,P*OS);
            //N = k^(dim_P)
            assert N mod k eq 0;
            dim_P:=Ilog(k,N);
            if dim_P gt 2 then
                return false; //S is not Bass at P
            end if;
        end for;
        return true;
    end if;
end intrinsic;


/* TEST

*/
