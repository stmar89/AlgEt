/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtIdl, 3;

/*TODO:

*/

declare type AlgEtIdl;
declare attributes AlgEtIdl : Index, //stores the index
                              Order, //order of definition. it might be smaller than the multiplicator ring
                              Algebra,
                              MultiplicatorRing,
                              Generators,
                              ZBasis,
                              IsPrime,
                              IsInvertible,
                              Inverse,
                              IsIntegral,
                              MinimalInteger,
                              PrimesAbove,
                              Factorization,
                              IsProductOfIdeals,
                              TraceDualIdeal,
                              Hash,
                              inclusion_matrix;

import "Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;

//----------
// Creation functions
//----------

CreateAlgEtIdl:=function(S,gens)
// Given S::AlgEtOrd and some generateors creates the new object 
// Here we just assign the generators. we do not compute the Zbasis unless necessary!
    A:=Algebra(S);
    I:=New(AlgEtIdl);
    I`Algebra:=A;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(A) then
        ZZ:=Integers();
        vprint AlgEtIdl,3: "CreateAlgEtIdl: too many gens";
        gens:=[g*s : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(A);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        //zb:=MatrixQtoA(A,P);
        zb:=MatrixQtoA(A,LLL(P)); // with LLL
        assert #zb eq AbsoluteDimension(A);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    if (assigned S`IsMaximal and IsMaximal(S)) or #gens eq 1 then
        I`IsInvertible:=true;
        I`MultiplicatorRing:=S; 
    end if;
    return I;
end function;

intrinsic Ideal(S::AlgEtOrd, gens::SeqEnum) -> AlgEtIdl
{Creates an ideal of S, generated by gens.}
    A:=Algebra(S);
    gensA:=[];
    for g in gens do
        bool,gA:=IsCoercible(A,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensA,gA);
    end for;
    return CreateAlgEtIdl(S,gensA);
end intrinsic;

intrinsic Ideal(S::AlgEtOrd, idls::Tup) -> AlgEtIdl
{Given an order S which is a product of orders S_i in the number fiedls generting the Algebra(S), and a Tup of ideals I_i of S_i, returns the S-ideal direct product of the I_i.}
    A:=Algebra(S);
    test,SasProd:=IsProductOfOrders(S);
    require test : "The order needs to be a product.";
    require #SasProd eq #idls : "The sequence does not contain enough ideals to generate a lattice in Algebra(S).";
    require forall{ i : i in [1..#idls] | Order(idls[i]) eq SasProd[i]} : "The ideals are not defined over the components of S.";
    A:=Algebra(S);
    _,embs:=Components(A);
    gens:=&cat[ [embs[i](g) : g in Generators(idls[i])] : i in [1..#idls] ];
    I:=Ideal(S,gens);
    I`IsProductOfIdeals:=<true,idls>;
    return I;
end intrinsic;

intrinsic Ideal(S::AlgEtOrd, gen::Any) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    id:=Ideal(S,[gen]);
    id`MultiplicatorRing:=S;
    return id;
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::AlgEtElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::AlgEtElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::RngIntElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::RngIntElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(S::AlgEtOrd, gen::FldRatElt) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic '*'(gen::FldRatElt, S::AlgEtOrd) -> AlgEtIdl
{Creates an ideal of S, generated by gen.}
    return Ideal(S,gen);
end intrinsic;

intrinsic Print(I::AlgEtIdl)
{Prints the ideal.}
  printf"Ideal of %o", Order(I);
end intrinsic;

//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtOrd,I::AlgEtIdl) -> AlgEtIdl
{Given an S-ideal I and an order T, returns the extension IT as a T-ideal. Note that if T is in S, then IT=I}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        id:=Ideal(T,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=I`MultiplicatorRing; //..as well as the MultiplicatorRing
        end if;
        return id;
    else //in this case Order(I) is strictly contained in T
        out:=Ideal(T,Generators(I));
        if (assigned T`IsMaximal and IsMaximal(T)) or (assigned I`IsInvertible and IsInvertible(I)) then
            out`IsInvertible:=true;
            out`MultiplicatorRing:=T;
        end if;
        return out;
    end if;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(I::AlgEtIdl) -> AlgEt
{Returns the Ã©tale algebra in which the ideal lives.}
    return I`Algebra;
end intrinsic;

intrinsic Order(I::AlgEtIdl) -> AlgEtOrd
{Returns the order of definition of the ideal.}
    return I`Order;
end intrinsic;

intrinsic ZBasis(I::AlgEtIdl)->SeqEnum[AlgEtElt]
{Returns a Z-basis of the ideal.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        A:=Algebra(I);
        S:=Order(I);
        gens:=[g*s : g in Generators(I) , s in ZBasis(S) ];
        if #Generators(I) eq 1 then
            zb:=gens; //gens is a ZBasis of I
        else
            dim:=AbsoluteDimension(A);
            M:=MatrixAtoQ(gens);
            d:=Integers()!Denominator(M);
            P:=hnf(crQZ(d*M));
            P:=(1/d)*crZQ(P);
            d:=Denominator(P); //this d might be different from Denomintor(M)
            hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
            // UNSAFE hash:=Hash(P);
            //zb:=MatrixQtoA(A,P);
            zb:=MatrixQtoA(A,LLL(P)); // with LLL
            assert #zb eq AbsoluteDimension(A);
            I`Hash:=hash;
        end if;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic Generators(I::AlgEtIdl) -> SeqEnum[AlgEtElt]
{Returns the generators of the ideal.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(Algebra(I));
    return I`Generators;
end intrinsic;

intrinsic myHash(I::AlgEtIdl)->RngInt
{Hash function}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(Algebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Inclusion and equality
//----------

intrinsic 'eq'(I::AlgEtIdl , J::AlgEtIdl ) -> BoolElt
{Equality testing.}
    require Algebra(I) cmpeq Algebra(J) : "The ideals are not in the same algebra.";
    require Order(I) cmpeq Order(J) : "The ideals are not over the same order.";
    if (assigned I`Generators and assigned J`Generators and Generators(I) eq Generators(J)) then
        // to compute myHash we need compute an HNF. In this way we might avoid it.
        out:=true;
        //note that the set of generators is not unique for an ideal.
    else
        out:=myHash(I) eq myHash(J);
    end if;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtIdl) do
            if assigned I``att and not assigned J``att then
                J``att:=I``att;
            elif assigned J``att and not assigned I``att then
                I``att:=J``att;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtIdl , J::AlgEtIdl ) -> BoolElt
{Equality testing}
    return not I eq J;
end intrinsic;

intrinsic 'eq'(I::AlgEtIdl, S::AlgEtOrd) -> BoolElt
{Return if I eq S. I needs to be an ideal of S.}
  assert Algebra(I) cmpeq Algebra(S);
  if Index(S, I) eq 1 then
      return I eq OneIdeal(S);
  else
      return false;
  end if;
end intrinsic;

intrinsic 'eq'(S::AlgEtOrd,I::AlgEtIdl) -> BoolElt
{Return if I eq S. I needs to be an ideal of S.}
    return I eq S;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtElt],I::AlgEtIdl) -> SeqEnum
{AbsoluteCoordiantes with respect to the ZBasis} 
    require forall{x : x in seq | Algebra(x) cmpeq Algebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtElt , I::AlgEtIdl ) -> BoolElt
{Returns if x is in I.}
    require Algebra(x) eq Algebra(I) : "the elements must lie in the same algebra of definition";
    /*if assigned I`Generators and x in I`Generators then 
        return true;
    end if;
    if assigned I`ZBasis and x in I`ZBasis then 
        return true;
    end if;
    mat := AbsoluteCoordinates([x], ZBasis(I))[1];
    return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
    */
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt , I::AlgEtIdl ) -> BoolElt
{Returns if x is in I.}
    return (Algebra(I)!x) in I;
end intrinsic;

intrinsic 'in'(x::FldRatElt , I::AlgEtIdl ) -> BoolElt
{Returns if x is in I.}
    return (Algebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(S::AlgEtOrd,I::AlgEtIdl) -> BoolElt
{given an ideal I of S, return if S subseteq I}
    assert Algebra(I) cmpeq Algebra(S);
    require Order(I) eq S: "the second argument must be an ideal of the first argument";
    return OneIdeal(S) subset I;
end intrinsic;

intrinsic 'subset'(I::AlgEtIdl,S::AlgEtOrd) -> BoolElt
{given an ideal I of S, return if I subseteq S}
    assert Algebra(I) cmpeq Algebra(S);
    require Order(I) eq S: "the first argument must be an ideal of the second argument";
    return I subset OneIdeal(S);
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtIdl, I2 :: AlgEtIdl) -> BoolElt
{Checks if the first argument is inside the second. The ideals need to be fractional}
  require Order(I1) eq Order(I2) : "The ideals must be in the same order.";
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtIdl) -> FldRatElt
{Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.}
  if not assigned T`Index then
    matT := MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtIdl, I::AlgEtIdl) -> Any
{Given fractional ideals J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I]}
    require Order(I) eq Order(J): "the ideals must be of the same order";
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;

intrinsic Index(S::AlgEtOrd, I::AlgEtIdl) -> Any
{given and ideal I of an order S returns [S:I] = [S:S cap I]/[I : S cap I] }
    require Order(I) eq S: "the ideal must be of the appropriate order";
    return Index(OneIdeal(S), I);
end intrinsic;


//----------
// Special ideals
//----------

intrinsic OneIdeal(S::AlgEtOrd) -> AlgEtIdl
{Given an order S returns the ideal 1*S which will be cached}
  if not assigned S`OneIdeal then
    S`OneIdeal := Ideal(S,One(S));
    S`OneIdeal`IsInvertible:=true;
    S`OneIdeal`MultiplicatorRing:=S;
  end if;
  return S`OneIdeal;
end intrinsic;

intrinsic Conductor(O::AlgEtOrd) ->AlgEtOrdIdl
{computes the conductor of an order}
    if not assigned O`Conductor then
        A:=Algebra(O);
        OA:=MaximalOrder(A);
        O`Conductor:=ColonIdeal(O,Ideal(O,ZBasis(OA)));
    end if;
    return O`Conductor;
end intrinsic;

//----------
// Binary operations
//----------

intrinsic '+'(I::AlgEtIdl , J::AlgEtIdl ) -> AlgEtIdl
{ returns the sum of two ideals }
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    if I eq J then
        return I;
    elif I subset J then
        return J;
    elif J subset I then
        return I;
    end if;
    S:=Order(I);
    gens:=Generators(I) cat Generators(J);
    return Ideal(S,gens);
end intrinsic;

intrinsic '*'(I::AlgEtIdl , J::AlgEtIdl ) -> AlgEtIdl
{Product of two ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    S:=Order(I);
    if I eq OneIdeal(S) then
        return J;
    elif J eq OneIdeal(S) then
        return I;
    end if;
    gI:=Generators(I);
    gJ:=Generators(J);
    if #gI eq 1 then //better for passing the attributes
        return J*gI[1];
    elif #gJ eq 1 then
        return I*gJ[1];
    else
        gens:=[i*j : i in gI, j in gJ ];
        out:=Ideal(S,gens);
        if assigned I`IsInvertible and assigned J`IsInvertible then
            out`IsInvertible:=IsInvertible(I) and IsInvertible(J);
        end if;
        return out;
    end if;
end intrinsic;

intrinsic '*'(I::AlgEtIdl , x::AlgEtElt ) -> AlgEtIdl
{Returns x*I.}
    bool,x:=IsCoercible(Algebra(I),x);
    if not bool then
        error "the element must be in the same algebra of I";
    else
        S:=Order(I);
        gens:=[i*x : i in Generators(I) ];
        id:=Ideal(S,gens);
        if assigned I`ZBasis and not assigned id`ZBasis then
            // id`ZBasis:=[x*z : z in ZBasis(I)];
            id`ZBasis:=MatrixQtoA(Algebra(I),LLL(MatrixAtoQ([x*z : z in ZBasis(I)])));
        end if;
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`IsInvertible then
            id`IsInvertible:=IsInvertible(I);
        end if;
        return id;
    end if;
end intrinsic;

intrinsic '*'(x::AlgEtElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    return I*x;
end intrinsic;

intrinsic '*'(x::RngIntElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtIdl, x::RngIntElt) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(x::FldRatElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtIdl, x::FldRatElt) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '^'(I::AlgEtIdl, n::RngIntElt) -> AlgEtIdl
{nth power of an ideal.}
    S:=Order(I);
    power_invertible:=function(I,n)
    // given an invertible ideal I and positive integer n return I^n

    // Lemma:
    // Let I be an invertible fractional S-ideal generated globally by I=aS+bS.
    // For every integer N, we have I^N=a^NS+b^NS.
    // Proof: we will show it locally at every prime. Since I is invertible, then it is locally principal.
    // Pick a prime P. Then by Nakayama's Lemma I_P=(a/1)S_P or I_P=(b/1)S_P. wlog assume the first. Then I_P^N=(a^N/1)S_P. QED.
    //
    // Remark: this trick does not work for product of invertible ideals I and J. 
    // One can have I_P1=(a) J_P1=(c) but I_P2=(a), J_P2=(d) so one cannot avoid the mixed products.
    
        TwoGeneratingSet(I);
        gg:=Generators(I);
        assert #gg le 2;
        out:=Ideal(Order(I),[g^n : g in gg]);
        out`IsInvertible:=true;
        if assigned I`MultiplicatorRing then 
            out`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`PrimesAbove then
            out`PrimesAbove:=PrimesAbove(I);
        end if;
        if assigned I`Factorization then
            out`Factorization:=< <fac[1],n*fac[2]> : fac in Factorization(I) >;
        end if;
        return out;
    end function;
    power_positive:=function(I, n)
        id := I;
        output := OneIdeal(S);
        bin_exp:=IntegerToSequence(n,2);
        for i in [1..#bin_exp] do
            if bin_exp[i] eq 1 then
                output *:= id;
            end if;
            if i lt #bin_exp then
                id := id*id;
            end if;
        end for;
        return output;
    end function;
    if n eq 0 then
        return OneIdeal(S);
    elif n eq 1 then
        return I;
    //elif n eq 2 then
    //    return I * I;
    else
        if n gt 0 then
           if assigned I`IsInvertible and IsInvertible(I) then
               return power_invertible(I,n);
           else
                return power_positive(I,n);
           end if;
        end if;
        if n lt 0 then
            invI:=Inverse(I);
            if n eq -1 then
                return invI;
            else
                return power_invertible(invI,-n);
            end if;
        end if;
    end if;
end intrinsic;
 
intrinsic 'meet'(I::AlgEtIdl, S::AlgEtOrd) -> AlgEtIdl
{given an ideal I of S, return S cap I}
    return S meet I;
end intrinsic;

intrinsic 'meet'(S::AlgEtOrd,I::AlgEtIdl) -> AlgEtIdl
{given an ideal I of S, return S cap I}
    output := OneIdeal(S) meet I;
    return output;
end intrinsic;

intrinsic 'meet'(I::AlgEtIdl, J::AlgEtIdl) -> AlgEtIdl
{given ideals I and J, return J cap I}
// this code is inspired by H.Cohen "Advanced Topics in ...", page 36.]
// note that the hnf in Magma is not the same as in the book. This is why the matrix M and P are take in a slightly different way compared to the refernce.
    require Algebra(I) eq Algebra(J): "the ideals must lie in the same algebra";
    require Order(I) eq Order(J): "the ideals must be defined over the same order";
    A:=Algebra(I);
    if I subset J then 
        return I;
    end if;
    if J subset I then
        return J;
    end if;

    /* further experiments seems to show that the version using the hermite normal form is faster
    id:=TraceDualIdeal(TraceDualIdeal(I)+TraceDualIdeal(J));
    if GetAssertions() gt 1 then
        zb:=meet_zbasis(ZBasis(I),ZBasis(J));
        id0:=Ideal(Order(I),zb);
        id0`ZBasis:=zb;
        assert id eq id0;
    end if;
    */ 
    zb:=meet_zbasis(ZBasis(I),ZBasis(J));
    id:=Ideal(Order(I),zb);
    id`ZBasis:=zb;
    return id;
end intrinsic;

//----------
// On Sequences
//----------

intrinsic '&+'(seq::SeqEnum[AlgEtIdl])->AlgEtIdl
{Returns the sum of the fractional ideals in the sequence.}
    id:=Ideal(Order(seq[1]),&cat[Generators(I):I in seq]);
    return id;
end intrinsic;

//----------
// ColonIdeals
//----------

intrinsic ColonIdeal(I::AlgEtIdl,J::AlgEtIdl)->AlgEtIdl
{Computes the colon ideal (I:J) (as an O-ideal) of two O-idealsi.}
    A:=Algebra(I);
    O := Order(I);
    require Order(J) eq O : "the ideals must be of the same order";
    if assigned J`Generators and #J`Generators eq 1 then
        j:=J`Generators[1];
        out:=(1/j)*I;
        return out;
    end if;
    //if assigned I`TraceDualIdeal then
    // // at a certain point I thought this would be faster, but it does not seem to be the case.
    //    IJ:=TraceDualIdeal(TraceDualIdeal(I)*J);
    //else
        // based on jv code
        N:=AbsoluteDimension(A);
        zbI:=ZBasis(I);
        //mIinv:=MatrixAtoQ(zbI)^-1;
        mIinv:=inclusion_matrix(I);
        zbJ:=ZBasis(J);
        bas:=AbsoluteBasis(A);
        M:=VerticalJoin([ Transpose( MatrixAtoQ([zj*bas[i] : i in [1..N]])*mIinv) : zj in zbJ] );
        d:=Denominator(M);
        P:=(1/d)*crZQ(hnf(crQZ(d*M)));
        P:=Transpose(P)^-1;
        // zbIJ:=MatrixQtoA(A,P);
        zbIJ:=MatrixQtoA(A,LLL(P)); //with LLL
        IJ:=Ideal(O,zbIJ);
        IJ`ZBasis:=zbIJ; //we know that zbIJ is a ZBasisA
    //end if;

    assert2 IJ*J subset I;
    return IJ;
end intrinsic;

intrinsic ColonIdeal(O::AlgEtOrd,J::AlgEtIdl)->AlgEtIdl
{computes the colon ideal (1*O:J) (as an O-ideal)}
    return ColonIdeal(OneIdeal(O), J);
end intrinsic;

intrinsic ColonIdeal(I::AlgEtIdl,O::AlgEtOrd)->AlgEtIdl
{computes the colon ideal (I:1*O) (as an O-ideal)}
    return I; //since we require O=Order(I)
end intrinsic;

intrinsic IsInvertible(I::AlgEtIdl) ->BoolElt
{ checks if the ideal I is invertible in its order of definition O }
    if not assigned I`IsInvertible then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        test:=One(O) in I*COI;
        I`IsInvertible:=test;
        if test then
            I`Inverse:=COI;
            I`MultiplicatorRing:=O;
            COI`IsInvertible:=true;
            COI`MultiplicatorRing:=O;
            COI`Inverse:=I;
            I`Inverse:=COI;
        end if;
    end if;
    return I`IsInvertible;
end intrinsic;

intrinsic Inverse(I::AlgEtIdl) ->AlgEtIdl
{computes the inverse of an ideal of a maximal order}
    require IsInvertible(I) : "the ideal is not invertible in the order of definition";
    if not assigned I`Inverse then
        O:=Order(I);
        COI:=ColonIdeal(O,I);
        COI`IsInvertible:=true;
        COI`MultiplicatorRing:=O;
        COI`Inverse:=I;
        I`Inverse:=COI;
    end if;
    return I`Inverse;
end intrinsic;

intrinsic MultiplicatorRing(I::AlgEtIdl) -> AlgEtOrd
{Given a fractional R-ideal I computes its multiplicator ring (I:I). If the overorders of R are known the corresponding overorder is returned, in order to preserve the known attributes.}
    if not assigned I`MultiplicatorRing then
        R:=Order(I);
        if #Generators(I) eq 1 then
            I`MultiplicatorRing:=R;
        elif assigned R`IsMaximal and R`IsMaximal then
            I`MultiplicatorRing:=R;
        elif assigned I`IsInvertible then
            I`MultiplicatorRing:=R;
        else 
            A:=Algebra(I);
            zbS:=ZBasis(ColonIdeal(I,I));
            S:=Order(zbS : Check:=0 );
            if assigned R`OverOrders then
            //this is to move the attributes
                ooR:=FindOverOrders(R);
                pos:=Index(ooR,S);
                S:=ooR[pos];
            end if;
            I`MultiplicatorRing:=S;
        end if;
    end if;
    return I`MultiplicatorRing;
end intrinsic;

//----------
// IsProductOfIdeals
//----------

intrinsic IsProductOfIdeals(I::AlgEtIdl) -> BoolElt, Tup
{Return if the argument is a product of ideals in number fields, and if so return also the sequence of these ideals (in the appropriate orders). Note: we require the Order(I) to be the MultiplicatorRing(I).}
    if not assigned I`IsProductOfIdeals then
        O:=Order(I);
        require O eq MultiplicatorRing(I) : "The ideal needs to be defined over its multiplicator ring.";
        A:=Algebra(O);
        test,orders:=IsProductOfOrders(O);
        if test then
            nf,_,projs:=Components(A); 
            zb:=ZBasis(I);
            ideals:=< ideal< orders[i] | [ projs[i](z) : z in zb ] > : i in [1..#orders] >;
            I`IsProductOfIdeals:=<true, ideals>;
        else
            I`IsProductOfIdeals:=<false,<>>;
        end if;
    end if;
    return Explode(I`IsProductOfIdeals);
end intrinsic;

//----------
// Random Elemnts
//----------

intrinsic Random(I::AlgEtIdl , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtElt
{Random element of I. The Coefficients are bounded by the positive integer bd. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
    require bd gt 0 : "The bound needs to be a positive integer.";
    B := ZBasis(I);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic Random(I::AlgEtIdl : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtElt
{ Returns a random (small coefficient) element of I. 
  The range of the random coefficients can be increased by giving the optional argument CoeffRange.
  One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
      return Random(I,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;

//----------
// Integral, Coprime, Minimal Integer and Coprime Representative
//----------

intrinsic IsCoprime(I::AlgEtIdl,J::AlgEtIdl) -> BoolElt
{given two integral ideals I and J of an order S, returns whether I+J=R}
    require Algebra(I) cmpeq Algebra(J) : "the ideals must lie in the same algebra";
    S:=Order(J);
    require Order(I) eq S: "the ideals must be over the same order";
    if I eq J then
        return false;
    end if;
    if assigned I`IsPrime and assigned J`IsPrime then
        if IsPrime(I) and IsPrime(J) then
            return true; //we already know that the ideals are distinct
        end if;
    end if;
    require IsIntegral(I) and IsIntegral(J): "the ideals must be integral";
    g:=GCD(MinimalInteger(I),MinimalInteger(J));
    if g eq 1 then
        return true;
    else
        return (One(S) in I+J); //here we generate a new ideal, which is expensive.
    end if;
end intrinsic;

intrinsic IsIntegral(I::AlgEtIdl) -> BoolElt
{returns wheter the ideal I of S is integral, that is I \subseteq S}
    if not assigned I`IsIntegral then
        S:=Order(I);
        I`IsIntegral:=I subset S;
    end if;
    return I`IsIntegral;
end intrinsic;

intrinsic MakeIntegral(I::AlgEtIdl) -> AlgEtIdl,RngIntElt
{given a fractional S ideal I, returns the ideal d*I,d when d is the smallest integer such that d*I is integral in S}
    if IsIntegral(I) then return I,1; end if;
    S:=Order(I);
    d:=LCM(&cat[ [Denominator(x_coord) : x_coord in x] : x in AbsoluteCoordinates(Generators(I),S)]);
    dI:=d*I;
    assert2 dI subset S;
    return dI, d;
end intrinsic;

intrinsic MinimalInteger(I::AlgEtIdl) -> RngIntElt
{returns the smallest integer contained in the ideal I}
    if not assigned I`MinimalInteger then
        require IsIntegral(I): "the ideal must be integral";
        ZZ:=Integers();
        coord:=AbsoluteCoordinates([One(Algebra(I))],I)[1];
        min:=LCM([ Denominator(c) : c in Eltseq(coord)]);
        assert2 min in I;
        I`MinimalInteger:=min;
    end if;
    return I`MinimalInteger;
end intrinsic;

intrinsic CoprimeRepresentative(I::AlgEtIdl,J::AlgEtIdl) -> AlgEtElt,AlgEtIdl
{return an element x such that x*I is an integral ideal coprime with J, togheter with the product x*I.. The first ideal must be invertible and the second should be integral}
    require IsIntegral(J) : "the second ideal must be integral";
    S:=Order(I);
    require S eq Order(J): "the ideals must be defined over the same order";
    x:=One(Algebra(I));
    xI:=I;
    while not IsCoprime(xI,J) do
        x:=Random(Inverse(I)); //Inverse is cached
        xI:=x*I;
    end while;
    vprintf AlgEtIdl,2: "CoprimeRepresentative:\n
                            I = %o\n,xI = %o\n",PrintSeqAlgEtElt(ZBasis(I)),PrintSeqAlgEtElt(ZBasis(xI));
    return x,xI;
end intrinsic;

/* Continue from here


*/

/* TEST

    AttachSpec("~/packages_github/AlgEt/spec");
    SetVerbose("AlgEtIdl",2);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    for i in [1..100] do
        a:=Random(A);
        assert 1 eq #{Ideal(E1,a),a*E1,E1*a};
        assert 1 eq #{Ideal(E2,a),a*E2,E2*a};
        assert a*E2 eq E2!!(a*E1);
        assert E1!!(E2!!(a*E1)) ne a*E1;
    end for;
    time #{ Random(E1)*E1 : i in [1..100] };
    a*E1 + E1!!(a*E2);
    time _:=&*[Random(E1)*E1 : i in [1..100]];
    time _:=&*[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    l:=[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    assert forall{ I : I in l | not assigned I`ZBasis };
    assert forall{ I : I in l | I eq Ideal(E1,ZBasis(I))};
    assert forall{ I : I in l | assigned I`ZBasis };
    time _:=&+[ i eq j select 1 else 0 : i,j in l ];
    time I:=Ideal(E1,[Random(E1) : i in [1..100]]);
    time J:=&*[I : i in [1..100]];
    time JJ:=I^100;
    time assert J eq JJ;
    time _:=&meet[(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    time assert forall{ I : I in [Random(E1)*E1 : i in [1..100]] | not IsProductOfIdeals(I)};
    time assert forall{ I : I in [Random(E2)*E2 : i in [1..100]] | IsProductOfIdeals(I)};
    time _:=[TraceDualIdeal(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    time _:=[IsIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];
    time _:=[MakeIntegral(Random(E1)*E1+Random(E1)*E1) : i in [1..100]];

    time ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..2000]]; 
    time _:=&meet(ids);
    time rr:=[ResidueRing(E1,I) : I in ids ];
    time cc:=[ ColonIdeal(I,J) : I,J in ids  ];

    O:=MaximalOrder(A);
    test,O_prod:=IsProductOfOrders(O);
    assert test;
    for i in [1..100] do
        _:=Ideal(O,<ideal< O_prod[i] | [Random(O_prod[i],3): j in [1..3]]> : i in [1..#O_prod] >);
    end for;

    SetAssertions(1);
    time ids:=[ Ideal(E1,[Random(E1) : i in [1..10]]) : i in [1..20]]; 
    time cc2:=[ TraceDualIdeal(TraceDualIdeal(I)*J) : I,J in ids  ];
    time cc:=[ ColonIdeal(I,J) : I,J in ids  ];
    assert cc eq cc2;


    K:=NumberField(x^2-5);
    _<y>:=PolynomialRing(K);
    E1:=NumberField(y^2-49*7*K.1);
    E2:=NumberField(y^5-25*7*K.1);
    A:=EtaleAlgebra([E1,E2]); 
    assert HasBaseField(A);
    time O:=MaximalOrder(A);
    for i in [1..100] do
        a:=Random(O);
        b:=Random(O);
        I:=Ideal(O,a);
        I:=a*O;
        I:=O*a;
    end for;
    time #{ Random(O)*O : i in [1..100] };
    a*O + O!!(a*O);
    time _:=&*[Random(O)*O : i in [1..100]];
    time _:=&*[(Random(O)*O+Random(O)*O) : i in [1..100]];
    time I:=Ideal(O,[Random(O) : i in [1..100]]);
    time J:=&*[I : i in [1..100]];
    time JJ:=I^100;
    time assert J eq JJ;
    time _:=&meet[(Random(O)*O+Random(O)*O) : i in [1..100]];
    time assert forall{ I : I in [Random(O)*O : i in [1..100]] | IsProductOfIdeals(I)};

//to modify from here on    
    A:=EtaleAlgebra([K,K]);
    for i in [1..100] do
        a:=Random(A);
        b:=Random(A);
        assert Trace(a)+Trace(b) eq Trace(a+b);
        assert Norm(a)*Norm(b) eq Norm(a*b);
    end for;


    seq:=[NumberField(p),NumberField(x^2-5)];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));
    for O in [O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;

    K:=NumberField(x^2-25*5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    E:=NumberField(p); //relative ext
    A:=EtaleAlgebra([E,E]);
    O:=MaximalOrder(A);
    for i in [1..100] do
        a:=Random(O);
        b:=Random(O);
        assert AbsoluteTrace(a)+AbsoluteTrace(b) eq AbsoluteTrace(a+b);
        assert Trace(a)+Trace(b) eq Trace(a+b);
        assert AbsoluteNorm(a)*AbsoluteNorm(b) eq AbsoluteNorm(a*b);
        assert Norm(a)*Norm(b) eq Norm(a*b);
    end for;


    A:=EtaleAlgebra([K]);
    O:=MaximalOrder(A);
    I:=Ideal(O,[Random(O) : i in [1..100]]);
    J:=Ideal(O,[Random(O) : i in [1..100]]);
    C:=ColonIdeal(I,J);
    CC:=&meet[(1/g)*I : g in Generators(J)];
    assert C eq CC;

    A:=EtaleAlgebra([E]);
    O:=MaximalOrder(A);
    I:=Ideal(O,[Random(O) : i in [1..100]]);
    J:=Ideal(O,[Random(O) : i in [1..100]]);
    C:=ColonIdeal(I,J);
    CC:=&meet[(1/g)*I : g in Generators(J)];
    assert C eq CC;

    // test if TwoGeneratingSet makes the power faster
    // Conlcusion: yes. By quite a bit!
	AttachSpec("~/packages_github/AlgEt/spec");
	_<x>:=PolynomialRing(Integers());
    f:=x^4-100*x^3-100*x^2-100*x-100;
    //f:=x^4-1000*x^3-1000*x^2-1000*x-1000;
    A:=EtaleAlgebra(f);
	E:=EquationOrder(A);
    P,p:=PicardGroup(E : GRH:=true); //this might take a while. timings are very inconsistent
    repeat
        Ii:=Random(P);
    until Ii ne Zero(P);
    I:=p(Ii);
    #Generators(I);
    
    delete I`IsInvertible;
    exp:=[ Random(2,30) : i in [1..100]];
    time l1:=[ I^i : i in exp ];
    #Generators(I);

    assert IsInvertible(I);
    TwoGeneratingSet(I);
    #Generators(I);
    time l2:=[ I^i : i in exp ];
    assert l1 eq l2;

    I:=SmallRepresentative(I);
    delete I`IsInvertible;
    time l1:=[ I^i : i in exp ];
    #Generators(I);

    assert IsInvertible(I);
    TwoGeneratingSet(I);
    #Generators(I);
    time l2:=[ I^i : i in exp ];
    assert l1 eq l2;

*/

