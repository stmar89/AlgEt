/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtMod, 3;

/*TODO:

*/

declare type AlgEtMod;
declare attributes AlgEtMod : Index, //stores the index
                              Order, // an order R
                              UniverseAlgebra, // A pair <V,m> where V is the algebra where M lives in, and m is the action Algebra(R)->V
                              //MultiplicatorRing,
                              Generators,
                              ZBasis,
                              IsDirectSumOfIdeals,
                              Hash,
                              inclusion_matrix;

import "Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;

/*TODO
*/

//----------
// Creation functions
//----------

CreateAlgEtMod:=function(S,m,gens)
// Given S::AlgEtOrd and some generateors creates the new object 
// m:Algebra(S)->Parent(gens[1]) determine the action
// Here we just assign the generators. we do not compute the Zbasis unless necessary!
    I:=New(AlgEtMod);
    V:=Codomain(m);
    I`UniverseAlgebra:=<V,m>;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(V) then
        ZZ:=Integers();
        vprintf AlgEtIdl,3: "too many gens";
        gens:=[g*m(s) : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    return I;
end function;

intrinsic Module(S::AlgEtOrd, m::Map, gens::SeqEnum) -> AlgEtMod
{Let K and V be AlgEt such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.}
    V:=Codomain(m);
    gensV:=[];
    for g in gens do
        bool,gV:=IsCoercible(V,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensV,gV);
    end for;
    return CreateAlgEtMod(S,m,gensV);
end intrinsic;

intrinsic Module(S::AlgEtOrd,m::Map,idls::Tup) -> AlgEtMod
{Let K and V be AlgEt such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in NumberFields(V), returns the sub-S-module of V generated by the direct sum of the ideals.}
    K:=Algebra(S);
    V:=Codomain(m);
    Vnf,Ve:=NumberFields(V);
    require #Vnf eq #idls and forall{ i : i in [1..#idls] | NumberField(Order(idls[i])) cmpeq Vnf[i]} : "The ideals do not generate an S-module in V.";
    gens:=&cat[ [Ve[i](z) : z in Basis(idls[i]) ] : i in [1..#Vnf]];
    I:=Module(S,m,gens);
    // note: I is generated by a direct sum, but might not be a direct sum.
    return I;
end intrinsic;

intrinsic Print(I::AlgEtMod)
{Prints the module.}
  printf"Module over %o", Order(I);
end intrinsic;


//----------
// Natural Action
//----------

intrinsic NaturalAction(K::AlgEt, V::AlgEt)->Map
{Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.}
    Knf:=[ DefiningPolynomial(L) : L in NumberFields(K) ];
    Vnf:=[ DefiningPolynomial(L) : L in NumberFields(V) ];
    require #Seqset(Knf) eq #NumberFields(K) : "The number fields defining K are not distinct";
    require Seqset(Knf) eq Seqset(Vnf) : "There is no componentwise diagonal action of K on V";
    ind:=[ Index(Knf,fV) : fV in Vnf]; // there is only one index in Knf for each fV since Knf is a product of distinct number fields
    mKV:=function(x)
        cx:=Components(x);
        y:=< cx[ind[i]] : i in  [1..#Vnf]>;
        return y;
    end function;
    m:=map< K->V | x:->mKV(x)>;
    return m;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic UniverseAlgebra(I::AlgEtMod) -> AlgEt,Map
{Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).}
    return Explode(I`UniverseAlgebra);
end intrinsic;

intrinsic Order(I::AlgEtMod) -> AlgEtOrd
{Returns the order of definition of the module.}
    return I`Order;
end intrinsic;

intrinsic Generators(I::AlgEtMod) -> SeqEnum[AlgEtElt]
{Returns the generators of the module.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(UniverseAlgebra(I));
    return I`Generators;
end intrinsic;

intrinsic ZBasis(I::AlgEtMod)->SeqEnum[AlgEtElt]
{Returns a Z-basis of the module.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        V,m:=UniverseAlgebra(I);
        S:=Order(I);
        gens:=[g*m(s) : g in Generators(I) , s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Integers()!Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic myHash(I::AlgEtMod)->RngInt
{Hash function}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(UniverseAlgebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Inclusion and equality
//----------

intrinsic 'eq'(I::AlgEtMod,J::AlgEtMod) -> BoolElt
{Equality testing.}
    V,m:=UniverseAlgebra(I);
    VJ,mJ:=UniverseAlgebra(I); 
    require V cmpeq VJ : "The modules are not in the same algebra.";
    // one should check that the action is the same, maybe with an assert2
    require Order(I) cmpeq Order(J) : "The modules are not over the same order.";
    out:=myHash(I) eq myHash(J);
    // if out then //we copy the attributes
    //     for att in GetAttributes(AlgEtIdl) do
    //         if assigned I``att and not assigned J``att then
    //             J``att:=I``att;
    //         elif assigned J``att and not assigned I``att then
    //             I``att:=J``att;
    //         end if;
    //     end for;
    // end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtMod , J::AlgEtMod ) -> BoolElt
{Equality testing}
    return not I eq J;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtElt],I::AlgEtMod) -> SeqEnum
{AbsoluteCoordiantes with respect to the ZBasis} 
    require forall{x : x in seq | Algebra(x) cmpeq UniverseAlgebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    require Algebra(x) eq UniverseAlgebra(I) : "the elements must lie in the same algebra of definition";
    // if assigned I`Generators and x in I`Generators then 
    //     return true;
    // end if;
    // if assigned I`ZBasis and x in I`ZBasis then 
    //     return true;
    // end if;
    // mat := AbsoluteCoordinates([x], ZBasis(I))[1];
    // return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'in'(x::FldRatElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtMod, I2 :: AlgEtMod) -> BoolElt
{Checks if the first argument is inside the second.}
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtMod) -> FldRatElt
{Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.}
  if not assigned T`Index then
    matT := MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtMod, I::AlgEtMod) -> Any
{Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I]}
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;


//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtOrd,I::AlgEtMod) -> AlgEtMod
{Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        _,m:=UniverseAlgebra(I);
        id:=Module(T,m,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        return id;
    else //in this case Order(I) is strictly contained in T
        _,m:=UniverseAlgebra(I);
        out:=Module(T,m,Generators(I));
        return out;
    end if;
end intrinsic;

//----------
// Quotients
//----------
intrinsic Quotient(I::AlgEtMod, J::AlgEtMod) -> GrpAb, Map
{ given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J } 
    // if J is not inside I, an error occurs while forming Q. so no need to check in advance
    A:=UniverseAlgebra(I);
	zbI := ZBasis(I);
	N := #zbI;
	F := FreeAbelianGroup(N);
	rel := [F ! cc : cc in AbsoluteCoordinates(ZBasis(J),I)];
	mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
	mIF := map<A->F| x:-> F ! AbsoluteCoordinates([x],I)[1]>;
	Q,qFQ := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
    q:=map< A->Q | x:->qFQ(mIF(x)) , y:-> mFI(y@@qFQ) >; 
    return Q,q;
end intrinsic;


/* CONTINUE from here

//----------
// Special ideals
//----------

intrinsic OneIdeal(S::AlgEtOrd) -> AlgEtIdl
{Given an order S returns the ideal 1*S which will be cached}
  if not assigned S`OneIdeal then
    S`OneIdeal := Ideal(S,One(S));
    S`OneIdeal`IsInvertible:=true;
    S`OneIdeal`MultiplicatorRing:=S;
  end if;
  return S`OneIdeal;
end intrinsic;

intrinsic Conductor(O::AlgEtOrd) ->AlgEtOrdIdl
{computes the conductor of an order}
    if not assigned O`Conductor then
        A:=Algebra(O);
        OA:=MaximalOrder(A);
        O`Conductor:=ColonIdeal(O,Ideal(O,ZBasis(OA)));
    end if;
    return O`Conductor;
end intrinsic;

//----------
// Binary operations
//----------

intrinsic '+'(I::AlgEtIdl , J::AlgEtIdl ) -> AlgEtIdl
{ returns the sum of two ideals }
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    if I eq J then
        return I;
    elif I subset J then
        return J;
    elif J subset I then
        return I;
    end if;
    S:=Order(I);
    gens:=Generators(I) cat Generators(J);
    return Ideal(S,gens);
end intrinsic;

intrinsic '*'(I::AlgEtIdl , J::AlgEtIdl ) -> AlgEtIdl
{Product of two ideals.}
    require Algebra(I) cmpeq Algebra(J) : "they must be ideals of the same algebra";
    require Order(I) cmpeq Order(J) : "they must be ideals of the same order";
    S:=Order(I);
    if I eq OneIdeal(S) then
        return J;
    elif J eq OneIdeal(S) then
        return I;
    end if;
    gI:=Generators(I);
    gJ:=Generators(J);
    if #gI eq 1 then //better for passing the attributes
        return J*gI[1];
    elif #gJ eq 1 then
        return I*gJ[1];
    else
        gens:=[i*j : i in gI, j in gJ ];
        out:=Ideal(S,gens);
        if assigned I`IsInvertible and assigned J`IsInvertible then
            out`IsInvertible:=IsInvertible(I) and IsInvertible(J);
        end if;
        return out;
    end if;
end intrinsic;

intrinsic '*'(I::AlgEtIdl , x::AlgEtElt ) -> AlgEtIdl
{Returns x*I.}
    bool,x:=IsCoercible(Algebra(I),x);
    if not bool then
        error "the element must be in the same algebra of I";
    else
        S:=Order(I);
        gens:=[i*x : i in Generators(I) ];
        id:=Ideal(S,gens);
        if assigned I`ZBasis then
            id`ZBasis:=[x*z : z in ZBasis(I)];
        end if;
        if assigned I`MultiplicatorRing then
            id`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`IsInvertible then
            id`IsInvertible:=IsInvertible(I);
        end if;
        return id;
    end if;
end intrinsic;

intrinsic '*'(x::AlgEtElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    return I*x;
end intrinsic;

intrinsic '*'(x::RngIntElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtIdl, x::RngIntElt) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(x::FldRatElt, I::AlgEtIdl) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '*'(I::AlgEtIdl, x::FldRatElt) -> AlgEtIdl
{Returns x*I.}
    A:=Algebra(I);
    return I*(A!x);
end intrinsic;

intrinsic '^'(I::AlgEtIdl, n::RngIntElt) -> AlgEtIdl
{nth power of an ideal.}
    S:=Order(I);
    power_invertible:=function(I,n)
    // given an invertible ideal I and positive integer n return I^n
        TwoGeneratingSet(I);
        gg:=Generators(I);
        out:=Ideal(Order(I),[g^n : g in gg]);
        out`IsInvertible:=true;
        if assigned I`MultiplicatorRing then 
            out`MultiplicatorRing:=MultiplicatorRing(I);
        end if;
        if assigned I`PrimesAbove then
            out`PrimesAbove:=PrimesAbove(I);
        end if;
        if assigned I`Factorization then
            out`Factorization:=< <fac[1],n*fac[2]> : fac in Factorization(I) >;
        end if;
        return out;
    end function;
    power_positive:=function(I, n)
        id := I;
        output := OneIdeal(S);
        bin_exp:=IntegerToSequence(n,2);
        for i in [1..#bin_exp] do
            if bin_exp[i] eq 1 then
                output *:= id;
            end if;
            if i lt #bin_exp then
                id := id*id;
            end if;
        end for;
        return output;
    end function;
    if n eq 0 then
        return OneIdeal(S);
    elif n eq 1 then
        return I;
    //elif n eq 2 then
    //    return I * I;
    else
        if n gt 0 then
            if assigned I`IsInvertible and IsInvertible(I) then
                return power_invertible(I,n);
            else
                return power_positive(I,n);
            end if;
        end if;
        if n lt 0 then
            invI:=Inverse(I);
            if n eq -1 then
                return invI;
            else
                return power_invertible(invI,-n);
            end if;
        end if;
    end if;
end intrinsic;
 
intrinsic 'meet'(I::AlgEtIdl, S::AlgEtOrd) -> AlgEtIdl
{given an ideal I of S, return S cap I}
    return S meet I;
end intrinsic;

intrinsic 'meet'(S::AlgEtOrd,I::AlgEtIdl) -> AlgEtIdl
{given an ideal I of S, return S cap I}
    output := OneIdeal(S) meet I;
    return output;
end intrinsic;

intrinsic 'meet'(I::AlgEtIdl, J::AlgEtIdl) -> AlgEtIdl
{given ideals I and J, return J cap I}
// this code is inspired by H.Cohen "Advanced Topics in ...", page 36.]
// note that the hnf in Magma is not the same as in the book. This is why the matrix M and P are take in a slightly different way compared to the refernce.
    require Algebra(I) eq Algebra(J): "the ideals must lie in the same algebra";
    require Order(I) eq Order(J): "the ideals must be defined over the same order";
    A:=Algebra(I);
    if I subset J then 
        return I;
    end if;
    if J subset I then
        return J;
    end if;

    // // further experiments seems to show that the version using the hermite normal form is faster
    // id:=TraceDualIdeal(TraceDualIdeal(I)+TraceDualIdeal(J));
    // if GetAssertions() gt 1 then
    //     zb:=meet_zbasis(ZBasis(I),ZBasis(J));
    //     id0:=Ideal(Order(I),zb);
    //     id0`ZBasis:=zb;
    //     assert id eq id0;
    // end if;
    zb:=meet_zbasis(ZBasis(I),ZBasis(J));
    id:=Ideal(Order(I),zb);
    id`ZBasis:=zb;
    return id;
end intrinsic;


//----------
// IsProductOfIdeals
//----------

intrinsic IsProductOfIdeals(I::AlgEtIdl) -> BoolElt, Tup
{Return if the argument is a product of ideals in number fields, and if so return also the sequence of these ideals (in the appropriate orders). Note: we require the Order(I) to be the MultiplicatorRing(I).}
    if not assigned I`IsProductOfIdeals then
        O:=Order(I);
        require O eq MultiplicatorRing(I) : "The ideal needs to be defined over its multiplicator ring.";
        A:=Algebra(O);
        test,orders:=IsProductOfOrders(O);
        if test then
            nf,_,projs:=NumberFields(A); 
            zb:=ZBasis(I);
            ideals:=< ideal< orders[i] | [ projs[i](z) : z in zb ] > : i in [1..#orders] >;
            I`IsProductOfIdeals:=<true, ideals>;
        else
            I`IsProductOfIdeals:=<false,<>>;
        end if;
    end if;
    return Explode(I`IsProductOfIdeals);
end intrinsic;

//----------
// Random Elemnts
//----------

intrinsic Random(I::AlgEtIdl , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtElt
{Random element of I. The Coefficients are bounded by the positive integer bd. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
    require bd gt 0 : "The bound needs to be a positive integer.";
    B := ZBasis(I);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic Random(I::AlgEtIdl : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtElt
{ Returns a random (small coefficient) element of I. 
  The range of the random coefficients can be increased by giving the optional argument CoeffRange.
  One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
      return Random(I,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;

*/


/* TEST

    AttachSpec("~/packages_github/AlgEt/spec");
    Attach("~/packages_github/AlgEt/Modules.m");
    _<x>:=PolynomialRing(Integers());
    m1:=x^4 - 2*x^2 + 9;
    m2:=x^2 -5*x + 7;
    K1:=NumberField(m1);
    K2:=NumberField(m2);
    K:=EtaleAlgebra([K1,K2]);
    V:=EtaleAlgebra([K1,K2,K1,K2,K2]);
    m:=NaturalAction(K,V);
    F:=PrimitiveElement(K);
    [MinimalPolynomial(c) : c in Components(m(F))];

    Vnf,Ve:=NumberFields(V);
    gens:=&cat[ [Ve[i](z) : z in Basis(MaximalOrder(Vnf[i])) ] : i in [1..#Vnf]];
    gens;
    O:=MaximalOrder(K);
    M:=Module(O,m,gens);
    N:=Module(O,m,< 1*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    Generators(M);
    ZBasis(M) eq ZBasis(N);
    assert N eq M;
    E:=EquationOrder(K);
    assert not IsMaximal(E);
    NE:=Module(E,m,< 1*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    assert N subset NE and NE subset N; // N has multiplicatorring O
    N2:=Module(E,m,< 4*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    assert N2 ne NE;
    assert N2 subset NE;
    assert not NE subset N2;
    
*/
