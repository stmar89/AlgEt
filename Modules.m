/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtMod, 3;

/*TODO:

*/

declare type AlgEtMod;
declare attributes AlgEtMod : Index, //stores the index
                              Order, // an order R
                              UniverseAlgebra, // A pair <V,m> where V is the algebra where M lives in, and m is the action Algebra(R)->V
                              //MultiplicatorRing,
                              Generators,
                              ZBasis,
                              IsDirectSumOfIdeals,
                              Hash,
                              inclusion_matrix;

import "Ord.m" : crQZ , crZQ , Columns , hnf , MatrixAtoQ , MatrixAtoZ , MatrixQtoA , meet_zbasis , inclusion_matrix;

/*TODO
*/

//----------
// Creation functions
//----------

CreateAlgEtMod:=function(S,m,gens)
// Given S::AlgEtOrd and some generateors creates the new object 
// m:Algebra(S)->Parent(gens[1]) determine the action
// Here we just assign the generators. we do not compute the Zbasis unless necessary!
    I:=New(AlgEtMod);
    V:=Codomain(m);
    I`UniverseAlgebra:=<V,m>;
    I`Order:=S;
    gens:=Setseq(Seqset(gens));
    if #gens gt AbsoluteDimension(V) then
        ZZ:=Integers();
        vprintf AlgEtIdl,3: "too many gens";
        gens:=[g*m(s) : g in gens, s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
        gens:=zb;
    end if;
    I`Generators:=gens;
    return I;
end function;

intrinsic Module(S::AlgEtOrd, m::Map, gens::SeqEnum) -> AlgEtMod
{Let K and V be AlgEt such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.}
    V:=Codomain(m);
    gensV:=[];
    for g in gens do
        bool,gV:=IsCoercible(V,g);
        if not bool then
            error "generators not in the algebra";
        end if;
        Append(~gensV,gV);
    end for;
    return CreateAlgEtMod(S,m,gensV);
end intrinsic;

intrinsic Module(S::AlgEtOrd,m::Map,idls::Tup) -> AlgEtMod
{Let K and V be AlgEt such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in NumberFields(V), returns the sub-S-module of V generated by the direct sum of the ideals.}
    K:=Algebra(S);
    V:=Codomain(m);
    Vnf,Ve:=NumberFields(V);
    require #Vnf eq #idls and forall{ i : i in [1..#idls] | NumberField(Order(idls[i])) cmpeq Vnf[i]} : "The ideals do not generate an S-module in V.";
    gens:=&cat[ [Ve[i](z) : z in Basis(idls[i]) ] : i in [1..#Vnf]];
    I:=Module(S,m,gens);
    // note: I is generated by a direct sum, but might not be a direct sum.
    return I;
end intrinsic;

intrinsic Print(I::AlgEtMod)
{Prints the module.}
  printf"Module over %o", Order(I);
end intrinsic;


//----------
// Natural Action
//----------

intrinsic NaturalAction(K::AlgEt, V::AlgEt)->Map
{Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.}
    Knf:=[ DefiningPolynomial(L) : L in NumberFields(K) ];
    Vnf:=[ DefiningPolynomial(L) : L in NumberFields(V) ];
    require #Seqset(Knf) eq #NumberFields(K) : "The number fields defining K are not distinct";
    require Seqset(Knf) eq Seqset(Vnf) : "There is no componentwise diagonal action of K on V";
    ind:=[ Index(Knf,fV) : fV in Vnf]; // there is only one index in Knf for each fV since Knf is a product of distinct number fields
    mKV:=function(x)
        cx:=Components(x);
        y:=< cx[ind[i]] : i in  [1..#Vnf]>;
        return y;
    end function;
    m:=map< K->V | x:->mKV(x)>;
    return m;
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic UniverseAlgebra(I::AlgEtMod) -> AlgEt,Map
{Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).}
    return Explode(I`UniverseAlgebra);
end intrinsic;

intrinsic Order(I::AlgEtMod) -> AlgEtOrd
{Returns the order of definition of the module.}
    return I`Order;
end intrinsic;

intrinsic Generators(I::AlgEtMod) -> SeqEnum[AlgEtElt]
{Returns the generators of the module.}
    if not assigned I`Generators then 
        I`Generators:=ZBasis(I);
    end if;
    assert2 #I`Generators le AbsoluteDimension(UniverseAlgebra(I));
    return I`Generators;
end intrinsic;

intrinsic ZBasis(I::AlgEtMod)->SeqEnum[AlgEtElt]
{Returns a Z-basis of the module.}    
    if not assigned I`ZBasis then
        assert assigned I`Generators;
        assert not assigned I`Hash; //if Hash is assigned then a ZBasis has been computed
        V,m:=UniverseAlgebra(I);
        S:=Order(I);
        gens:=[g*m(s) : g in Generators(I) , s in ZBasis(S) ];
        dim:=AbsoluteDimension(V);
        M:=MatrixAtoQ(gens);
        d:=Integers()!Denominator(M);
        P:=hnf(crQZ(d*M));
        P:=(1/d)*crZQ(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        zb:=MatrixQtoA(V,P);
        assert #zb eq AbsoluteDimension(V);
        I`Hash:=hash;
        I`ZBasis:=zb;
    end if;
    return I`ZBasis;
end intrinsic;

intrinsic myHash(I::AlgEtMod)->RngInt
{Hash function}
    if not assigned I`Hash then
        dim:=AbsoluteDimension(UniverseAlgebra(I));
        P:=MatrixAtoQ(ZBasis(I));
        d:=Integers() ! Denominator(P);
        P:=(1/d)*crZQ(hnf(crQZ(d*P)));
        assert2 IsUpperTriangular(P);
        d:=Denominator(P); //this d might be different from Denomintor(M)
        hash:=[d] cat [(d*P[i,j]) : j in [i..dim] , i in [1..dim]];
        // UNSAFE hash:=Hash(P);
        I`Hash:=hash;
    end if;
    return I`Hash;
end intrinsic;

//----------
// Inclusion and equality
//----------

intrinsic 'eq'(I::AlgEtMod,J::AlgEtMod) -> BoolElt
{Equality testing.}
    V,m:=UniverseAlgebra(I);
    VJ,mJ:=UniverseAlgebra(I); 
    require V cmpeq VJ : "The modules are not in the same algebra.";
    // one should check that the action is the same, maybe with an assert2
    require Order(I) cmpeq Order(J) : "The modules are not over the same order.";
    out:=myHash(I) eq myHash(J);
    // if out then //we copy the attributes
    //     for att in GetAttributes(AlgEtIdl) do
    //         if assigned I``att and not assigned J``att then
    //             J``att:=I``att;
    //         elif assigned J``att and not assigned I``att then
    //             I``att:=J``att;
    //         end if;
    //     end for;
    // end if;
    return out;
end intrinsic;

intrinsic 'ne'(I::AlgEtMod , J::AlgEtMod ) -> BoolElt
{Equality testing}
    return not I eq J;
end intrinsic;

intrinsic AbsoluteCoordinates(seq::SeqEnum[AlgEtElt],I::AlgEtMod) -> SeqEnum
{AbsoluteCoordiantes with respect to the ZBasis} 
    require forall{x : x in seq | Algebra(x) cmpeq UniverseAlgebra(I)} : "the algebra is not the same";
    Minv:=inclusion_matrix(I);
    M:=MatrixAtoQ(seq)*Minv;
    return [Eltseq(r) : r in Rows(M)];
end intrinsic;

intrinsic 'in'(x::AlgEtElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    require Algebra(x) eq UniverseAlgebra(I) : "the elements must lie in the same algebra of definition";
    // if assigned I`Generators and x in I`Generators then 
    //     return true;
    // end if;
    // if assigned I`ZBasis and x in I`ZBasis then 
    //     return true;
    // end if;
    // mat := AbsoluteCoordinates([x], ZBasis(I))[1];
    // return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
    ZZ:=Integers();
    coord:=AbsoluteCoordinates([x],I)[1];
    is_in:=forall{m : m in coord | IsCoercible(ZZ,m)};
    return is_in;
end intrinsic;

intrinsic 'in'(x::RngIntElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'in'(x::FldRatElt , I::AlgEtMod ) -> BoolElt
{Returns if x is in I.}
    return (UniverseAlgebra(I)!x) in I;
end intrinsic;

intrinsic 'subset'(I1 :: AlgEtMod, I2 :: AlgEtMod) -> BoolElt
{Checks if the first argument is inside the second.}
  if not Index(I2, I1) in Integers() then
    return false;
  end if;
  return forall{ x : x in Generators(I1) | x in I2};
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtMod) -> FldRatElt
{Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.}
  if not assigned T`Index then
    matT := MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(J::AlgEtMod, I::AlgEtMod) -> Any
{Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I]}
  out:=Index(I)/Index(J);
  if IsCoercible(Integers(),out) then
    out:=Integers()!out;
  end if;
  return out;
end intrinsic;


//----------
// Coercion
//----------

intrinsic '!!'(T::AlgEtOrd,I::AlgEtMod) -> AlgEtMod
{Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I}
    if Order(I) eq T then
        return I;
    elif T subset Order(I) then
        //in this case, Generators of I might not be a generating set over T
        _,m:=UniverseAlgebra(I);
        id:=Module(T,m,ZBasis(I));
        id`ZBasis:=ZBasis(I); //the ZBasis stays the same..
        return id;
    else //in this case Order(I) is strictly contained in T
        _,m:=UniverseAlgebra(I);
        out:=Module(T,m,Generators(I));
        return out;
    end if;
end intrinsic;

//----------
// Quotients
//----------

intrinsic Quotient(I::AlgEtMod, J::AlgEtMod) -> GrpAb, Map
{ given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J } 
    // if J is not inside I, an error occurs while forming Q. so no need to check in advance
    A:=UniverseAlgebra(I);
    zbI := ZBasis(I);
    N := #zbI;
    F := FreeAbelianGroup(N);
    rel := [F ! cc : cc in AbsoluteCoordinates(ZBasis(J),I)]; //using inclusion_matrix. Fast!
    mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
    mIF := map<A->F| x:-> F ! AbsoluteCoordinates([x],I)[1]>;
    Q,qFQ := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
   q:=map< A->Q | x:->qFQ(mIF(x)) , y:-> mFI(y@@qFQ) >; 
   return Q,q;
end intrinsic;


/* TEST

    AttachSpec("~/packages_github/AlgEt/spec");
    Attach("~/packages_github/AlgEt/Modules.m");
    _<x>:=PolynomialRing(Integers());
    m1:=x^4 - 2*x^2 + 9;
    m2:=x^2 -5*x + 7;
    K1:=NumberField(m1);
    K2:=NumberField(m2);
    K:=EtaleAlgebra([K1,K2]);
    V:=EtaleAlgebra([K1,K2,K1,K2,K2]);
    m:=NaturalAction(K,V);
    F:=PrimitiveElement(K);
    [MinimalPolynomial(c) : c in Components(m(F))];

    Vnf,Ve:=NumberFields(V);
    gens:=&cat[ [Ve[i](z) : z in Basis(MaximalOrder(Vnf[i])) ] : i in [1..#Vnf]];
    gens;
    O:=MaximalOrder(K);
    M:=Module(O,m,gens);
    N:=Module(O,m,< 1*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    Generators(M);
    ZBasis(M) eq ZBasis(N);
    assert N eq M;
    E:=EquationOrder(K);
    assert not IsMaximal(E);
    NE:=Module(E,m,< 1*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    assert N subset NE and NE subset N; // N has multiplicatorring O
    N2:=Module(E,m,< 4*MaximalOrder(Vnf[i]) : i in [1..#Vnf] >);
    assert N2 ne NE;
    assert N2 subset NE;
    assert not NE subset N2;
    Quotient(N,NE); 

*/
