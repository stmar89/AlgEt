/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Functions for order in Etale Q algebras
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose AlgEtOrd, 3;

/*TODO:
*/


declare type AlgEtOrd;

declare attributes AlgEt : MaximalOrder,
                           ProductOfEquationOrders,
                           EquationOrder;

declare attributes AlgEtOrd : IsMaximal,
                              IsProductOfOrders,
                              Index,
                              ZBasis,
                              Generators,
                              OneIdeal,
                              Algebra,
                              TraceDualIdeal,
                              Conductor,
                              IsGorenstein,
                              IsBass,
                              Hash;

//----------
// Basics
//----------

intrinsic Print(A::AlgEtOrd)
{Print the order.}
  printf"Order in Etale Algebra given by %o", A`Algebra;
end intrinsic;

intrinsic IsCoercible(S::AlgEtOrd, x::.) -> BoolElt, Any
{Return whether x is coercible into S and the result if so.}
    bool,x:=IsCoercible(Algebra(S),x);
    if bool and x in S then
        return true,x;
    else
        return false,_;
    end if;
end intrinsic;

//----------
// Auxiliary functions
//----------

crZQ:=function(M)
//given a matrix M over the Integers() changes the base ring to Rationals()
    return ChangeRing(M,Rationals());
end function;

crQZ:=function(M)
//given a matrix M over the Rationals() changes the base ring to Integers()
    return ChangeRing(M,Integers());
end function;

Columns:=function(M)
    return Rows(Transpose(M));
end function;

hnf:=function(M)
//input: a matrix over the Integers() 
//output: the matrix in HNF
    N:=Rank(M);
    H:=HermiteForm(M);
    H:=Matrix(Rows(H)[1..N]);
    return H;
end function;

MatrixAtoQ:=function(gens)
//input:  a sequence of elements of an AlgEt A
//output: a matrix over Rationals() whose coordinates are the AbsoluteCoordinates of gens
    return Matrix([AbsoluteCoordinates(g) : g in gens]);
end function;

MatrixAtoZ:=function(gens)
//return a matrix with integers entries which rows the elements of gens
    return crQZ(MatrixAtoQ(gens));
end function;

MatrixQToA:=function(A,P)
//given a matrix with Integer or Rational entries, returns a sequence of elements of A, corresponding to the rows.
    abs:=AbsoluteBasis(A);
    abs_dim:=AbsoluteDimension(A);
    assert #Columns(P) eq abs_dim;
    return [ &+[Eltseq(r)[i]*abs[i] : i in [1..abs_dim]] : r in Rows(P)];
end function;

//----------
// Creation
//----------

intrinsic Order( gens::SeqEnum[AlgEtElt] : Check:=100 ) -> AlgEtOrd
{Construnct the order generated by gens over the rationals. The parameter Check (default 100) determines how many times the program tries to obtain a multiplicatively closed lattice by adding the product of the generators. If Check 0 then this step is skipped.}
    A:=Universe(gens);
    gens:=Setseq(Seqset(gens));// we remove duplicates
    dim:=AbsoluteDimension(A);
    R:=New(AlgEtOrd);
    R`Algebra:=A;
    require forall{g : g in gens | IsIntegral(g) } : "The elements are not all integral, hence do not generate an order.";
    if Check gt 0 then 
        gens0:=gens;
        if not One(A) in gens then
            gens0:=[One(A)] cat gens0;
        end if;
        M:=MatrixAtoQ(gens0);
        d:=Denominator(M);
        P:=crZQ(hnf(crQZ(d*M)))/d;
        gens0:=MatrixQToA(A,P);
        fail:=0;
        repeat
            P_old:=P;
            gens0 cat:= [(g1*g2) : g1,g2 in gens0];
            M:=MatrixAtoQ(gens0);
            d:=Denominator(M);
            M:=crQZ(M*d);
            P:=crZQ(hnf(M))/d;
            gens0:=MatrixQToA(A,P);
            fail +:=1;
            go:=Rank(P_old) eq dim and P eq P_old;
        until go or fail gt Check;
        if fail gt Check then 
            error "The program could not generate a multiplicatively closed set from the given generators. Try to increase the value of Check, or choose different generators.";
        end if;

        d:=Denominator(P); //this d might be different from Denomintor(M)
        // we compute the Hash
        R`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
        zb:=MatrixQToA(A,P);
    else
    //we assume that gens is a ZBasis of a multiplicativly closed lattice
        zb:=gens;
    end if;

    assert #zb eq dim;
    if #gens le dim then
        R`Generators:=gens;
    else
        R`Generators:=zb;
    end if;
        R`ZBasis:=zb;
    assert2 One(A) in R;
    return R;
end intrinsic;

intrinsic Order(A::AlgEt , orders::Tup) -> AlgEtOrd
{Given a sequence of order in the number fiedls defining the etale algebra A, generates the product order.}
    nf,embs,projs:=NumberFields(A);
    require #nf eq #orders and forall{ i : i in [1..#orders] | NumberField(orders[i]) eq nf[i]} and 
forall{ S : S in orders | Type(S) eq RngOrd } : "The second input should be a sequence of orders in the number fields defining A";
    gens:=&cat[ [ embs[i](z) : z in AbsoluteBasis(orders[i]) ] : i in [1..#nf] ];
    O:=Order(gens : Check:=0); // the gens given generate a multiplicatively closed lattice in A
    assert2 O eq Order(gens);
    O`IsProductOfOrders:=<true,orders>;
    return O;
end intrinsic;

intrinsic OrderOver( gens::SeqEnum[AlgEtElt] , S::RngOrd : Check:=100 ) -> AlgEtOrd
{Given elements gens from an etale algebra A over a base field F and an order S in F, returns the order in A generated by gens over S. The parameter Check (default <true,100>) determines whether the programs checks if gens create a multiplicatively closed lattice, and if not adds elements until it is so, for Check[2] times.}
    A:=Universe(gens);
    F,mFA:=BaseField(A);
    require NumberField(S) eq F : "The base order does not lie in the bse field.";
    bOFinA:=[ mFA(b) : b in Basis(S)];
    gens:=[ g * b : g in gens, b in bOFinA ];
    return Order( gens : Check:=Check );
end intrinsic;

//----------
// Access the attributes
//----------

intrinsic Algebra(S::AlgEtOrd) -> AlgEt
{Returns the algebra of the order.}
  return S`Algebra;
end intrinsic;

intrinsic myHash(S::AlgEtOrd)->SeqEnum[RngInt]
{hash function for AlgEtOrd}
// two orders have the hash iff they are equal
    if not assigned S`Hash then
        dim:=AbsoluteDimension(Algebra(S));
        P:=MatrixAtoQ(ZBasis(S));
        d:=Denominator(P);
        P:=(1/d)*hnf(crQZ(d*P));
        d:=Denominator(P);
        assert2 IsUpperTriangular(P);
        S`Hash:=[d] cat [(Integers()!(d*P[i,j])) : j in [i..dim] , i in [1..dim]];
    end if;
    return S`Hash;
end intrinsic;

intrinsic ZBasis(S::AlgEtOrd)->SeqEnum[AlgEtElt]
{Return a Z-basis of the order.}    
    // assigned at creation
    return S`ZBasis;
end intrinsic;

intrinsic Generators(S::AlgEtOrd)->SeqEnum[AlgEtElt]
{Return a set of generators of the order.}    
    // assigned at creation
    return S`Generators;
end intrinsic;

//----------
// Equality
//----------

intrinsic 'eq'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same etale algebra";
    if O1`Generators eq O2`Generators or O1`ZBasis eq O2`ZBasis or myHash(O1) eq myHash(O2) then 
        out:=true;
    else
        out:=false;
    end if;
    vprintf AlgEtOrd,3 : "output of equality = %o\n",out;
    if out then //we copy the attributes
        for att in GetAttributes(AlgEtOrd) do
            if assigned O1``att and not assigned O2``att then
                O2``att:=O1``att;
            elif assigned O2``att and not assigned O1``att then
                O1``att:=O2``att;
            end if;
        end for;
    end if;
    return out;
end intrinsic;

//----------
// Inclusion
//----------

intrinsic 'in'(x::AlgEtElt,O::AlgEtOrd) -> BoolElt
{inclusion of elements} 
    require Algebra(x) cmpeq Algebra(O) : "the algebra is not the same";
    if (assigned O`Generators and x in O`Generators)
        or (assigned O`ZBasis and x in O`ZBasis) then
        return true;
    end if;
    mat := AbsoluteCoordinates([x], ZBasis(O))[1];
    return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

intrinsic 'in'(x::RngIntElt,O::AlgEtOrd) -> BoolElt
{inclusion of elements} 
    return (Algebra(O)!x) in O;
end intrinsic;

intrinsic 'in'(x::FldRatElt,O::AlgEtOrd) -> BoolElt
{inclusion of elements} 
    return (Algebra(O)!x) in O;
end intrinsic;

//----------
// Elements in orders
//----------

intrinsic One(S::AlgEtOrd)->AlgEtElt
{unit element of S}
    A:=Algebra(S);
    return One(A);
end intrinsic;

intrinsic Zero(S::AlgEtOrd)->AlgEtElt
{zero element of S}
    A:=Algebra(S);
    return Zero(A);
end intrinsic;

intrinsic Random(O::AlgEtOrd , bd::RngIntElt : ZeroDivisorsAllowed:=false ) -> AlgEtElt
{Random element of O. The Coefficients are bounded by the positive integer bd. One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
    require bd gt 0 : "The bound needs to be a positive integer.";
    B := ZBasis(O);
    if ZeroDivisorsAllowed then
       elt:=&+[ Random([-bd..bd])*b : b in B];
    else 
        repeat
            elt:=&+[ Random([-bd..bd])*b : b in B];
        until not IsZeroDivisor(elt);
    end if;
    return elt;
end intrinsic;

intrinsic Random(O::AlgEtOrd : CoeffRange:=3, ZeroDivisorsAllowed:=false ) -> AlgEtElt
{ Returns a random (small coefficient) element of O. 
  The range of the random coefficients can be increased by giving the optional argument CoeffRange.
  One can allow zero-divisors using the optional argument "ZeroDivisorsAllowed", which by default is set to false }
      return Random(O,CoeffRange : ZeroDivisorsAllowed:=ZeroDivisorsAllowed);
end intrinsic;

//----------
// Equation Orders
//----------

intrinsic EquationOrder(A::AlgEt) -> AlgEtOrd
{Given an étale algebra defined by a polynomial, returns the monogenic order defined by the same polynomial}
    if not assigned A`EquationOrder then
        require PrimeField(A) eq BaseField(A) : "Defined only for algebras over the Rationals()";
        pow:=PowerBasis(A);
        E:=Order(pow : Check:=0); //the PowerBasis genertes a mutliplicativelyclosed lattice
        assert2 E eq Order([pow[2]]);
        E`Generators:=[pow[2]]; // I want the genertor set to be small, so I put only the primitive element
        A`EquationOrder:=E;
    end if;
    return A`EquationOrder;
end intrinsic;

intrinsic ProductOfEquationOrders(A::AlgEt)->AlgEtOrd
{Given a product of number field A, returns the order consisting of the product of the equation orders of the number fields.}
    if not assigned A`ProductOfEquationOrders then
        A`ProductOfEquationOrders := Order( A , <EquationOrder(E) : E in NumberFields(A)> );
    end if;
    return A`ProductOfEquationOrders ;
end intrinsic;

//----------
// Maximal Order
//----------

intrinsic MaximalOrder(A::AlgEt)->AlgEtOrd
{Returns the maximal order of the étale algebra A.}
    if not assigned A`MaximalOrder then    
        O:=Order( A , <MaximalOrder(E) : E in NumberFields(A)> );
        O`IsMaximal:=true;
        A`MaximalOrder:=O;
    end if;
    return A`MaximalOrder;
end intrinsic;

intrinsic IsMaximal(S::AlgEtOrd) -> BoolElt
{Returns wheter the given order is the maximal order of the étale algebra.}
    if not assigned S`IsMaximal then
        O:=MaximalOrder(Algebra(S));
        S`IsMaximal:=S eq O;
    end if;
    return S`IsMaximal;
end intrinsic;

//----------
// IsProduct
//----------

intrinsic IsProductOfOrders(O::AlgEtOrd)->BoolElt, Tup
{Return if the argument is a product of orders in number fields, and if so return also the sequence of these orders.}
    if not assigned O`IsProductOfOrders then
        A:=Algebra(O);
        idem:=OrthogonalIdempotents(A);
        test:=forall{x : x in idem | x in O};
        if test then
            nf,_,projs:=NumberFields(A); 
            if #nf eq 1 then
                orders:=<O>;
            else
                zb:=ZBasis(O);
                require PrimeField(A) eq BaseField(A) : "We require the algebra to be defined over the Rationals(). The reason is that we don't have a functioning method to create orders in relative number fields which are not over the maximal order of the base field. One can still check if the order O is a product by cehcking if OrthogonalIdempotents(A) are in O."; 
                orders:=< Order( [ projs[i](z) : z in zb ] ) : i in [1..#idem] >;
                assert2 O eq Order(A,orders);
            end if;
            O`IsProductOfOrders:=<true,orders>;
        else
            O`IsProductOfOrders:=<false,<>>;
        end if;
    end if;
    return Explode(O`IsProductOfOrders);
end intrinsic;

//----------
// Index
//----------

intrinsic Index(T::AlgEtOrd) -> FldRatElt
{given an order T computes its index with respect to the basis of the algebra of T as a free Z-module}
  if not assigned T`Index then
    matT:=MatrixAtoQ(ZBasis(T));
    T`Index := Abs(Rationals() ! Determinant(matT));
  end if;
  return T`Index;
end intrinsic;

intrinsic Index(S::AlgEtOrd, T::AlgEtOrd) -> Any
{given two orders T \subset S, returns [S:T] = #S/T }
  assert Algebra(T) cmpeq Algebra(S);
  elt := Index(T)/Index(S);
  if IsCoercible(Integers(), elt) then
    elt := Integers() ! elt;
  end if;
  return elt;
end intrinsic;

//----------
// Subset and product of orders
//----------

intrinsic 'subset'(O1 :: AlgEtOrd, O2 :: AlgEtOrd) -> BoolElt
{Checks if the first argument is inside the second.}
  require Algebra(O1) cmpeq Algebra(O2) : "The orders must be in the same algebra.";
  if not Index(O2, O1) in Integers() then
    return false;
  end if;
  mat := Matrix(AbsoluteCoordinates(Generators(O1), ZBasis(O2)));
  return &and[IsCoercible(Integers(), elt) : elt in Eltseq(mat)];
end intrinsic;

intrinsic '*'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if O1 eq O2 then
        return O1;
    end if;
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O1;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O2;
    end if;
    if O1 subset O2 then
        return O2;
    end if;
    if O2 subset O1 then
        return O1;
    end if;
    gens:=Setseq( Seqset(Generators(O1) cat Generators(O2)) );
    return Order(gens);
end intrinsic;

//----------
// Intersection
//----------

meet_zbasis:=function(zb1,zb2)
//Returns the ZBasis of the intersection of the lattices gerated by the gven two Z-bases.
    A:=Algebra(zb1[1]);
    N:=#zb1;
    MI:=crZQ(MatrixAtoQ(zb1));
    MJ:=crZQ(MatrixAtoQ(zb2));
    dI:=Integers() ! Denominator(MI);
    dJ:=Integers() ! Denominator(MJ);
    d:=LCM(dI,dJ);
    MI:=crQZ(d*MI);
    MJ:=crQZ(d*MJ);
    MZ:=ZeroMatrix(Integers(),N,N);
    M:=Matrix(HorizontalJoin(VerticalJoin(MI,MJ),VerticalJoin(MI,MZ)));
    M:=hnf(M);
    //the hnf of zb1 meet zb2 is the lower-right quadrant of M
    P:=Matrix(N,N,[M[i,j] : i,j in [N+1..2*N]]);
    P:=(1/d)*crZQ(P);
    zb:=MatrixQToA(A,P);
    return zb;
end function;


intrinsic 'meet'(O1::AlgEtOrd,O2::AlgEtOrd)->BoolElt
{checks equality of orders in an etale Algebra}
    require Algebra(O1) cmpeq Algebra(O2) : "the orders must be defined in the same algebra";
    if assigned O1`IsMaximal and O1`IsMaximal then 
    //calling IsMaximal(O1) would trigger the computation of the maximal order, which might be expensive
        return O2;
    end if;
    if assigned O2`IsMaximal and O2`IsMaximal then
        return O1;
    end if;
    if O1 eq O2 then
        return O1;
    end if;
    if O1 subset O2 then
        return O1;
    end if;
    if O2 subset O1 then
        return O2;
    end if;
    zb:=meet_zbasis(ZBasis(O1),ZBasis(O2));
    O:=Order(zb : Check:=0 ); //the intersecion of two orders is multiplicatively closed
    assert2 O eq Order(zb);
    return O;
end intrinsic;

//----------
// Others
//----------

intrinsic MultiplicatorRing(R::AlgEtOrd) -> AlgEtOrd
{Returns the MultiplicatorRing of an order R, that is R itself.}
    return R;
end intrinsic;

/* CONTINUE from HERE

intrinsic ListToSequence(L::List)->SeqEnum
{given a list of elements returns the same sequence}
    return [s : s in L];
end intrinsic;

intrinsic Discriminant(R::AlgEtOrd) -> RngInt
{returns the discriminant of the order}
    return Discriminant(AssOrder(R));
end intrinsic;
*/

/* TEST
    
    Attach("~/packages_github/AlgEt/AlgEt.m");
    Attach("~/packages_github/AlgEt/Elt.m");
    Attach("~/packages_github/AlgEt/Ord.m");
    SetVerbose("AlgEtOrd",2);
    SetAssertions(2);

    _<x>:=PolynomialRing(Integers());
    f:=(x^8+16)*(x^8+81);
    A:=EtaleAlgebra(f);
    time O1:=Order(Basis(A));
    ZBasis(O1);
    Generators(O1);
    time O2:=Order(AbsoluteBasis(A) : Check:=0);
    time O3:=Order(AbsoluteBasis(A));
    time O1 eq O2;
    time O2 eq O3;
    assert EquationOrder(A) ne ProductOfEquationOrders(A);
    
    OA:=MaximalOrder(A);
    O:=Order(ZBasis(OA));
    assert not assigned O`IsMaximal;
    assert O eq OA;
    assert assigned O`IsMaximal;

    O:=Order(ZBasis(OA));
    assert IsProductOfOrders(O);
    assert IsMaximal(O);

    O:=MaximalOrder(A);
    time G:=[[ Random(O) : i in [1..3] ] : i in [1..100]];
    time S:=[ Order(s) : s in G ];
    time #Seqset(S);

    assert forall{z : z in ZBasis(O1) | z in O1 };
    for O in [O1,O2,O3] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;


    seq:=[x^2-5*25,x^2-7*49];
    seq:=[NumberField(f) : f in seq];
    A:=EtaleAlgebra(seq);
    time O1:=Order(Basis(A));
    time O2:=Order(AbsoluteBasis(A));
    time O1 eq O2;
    for O in [O1,O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;
    
    E1:=EquationOrder(A);
    E2:=ProductOfEquationOrders(A);
    E3:=Order(A,<EquationOrder(seq[1]) , MaximalOrder(seq[2])>);
    E4:=Order(A,<MaximalOrder(seq[1]) , EquationOrder(seq[2])>);
    OA:=MaximalOrder(A);
    for E in [E1,E2,E3,E4] do 
        Index(OA,E);
    end for;
    E1 subset E2;
    E1 subset E3;
    E3*E4 eq OA;
    OA meet E1 eq E1;
    E2 meet E1 eq E2;
    E3 meet E4 eq E2;
    O:=MaximalOrder(A);
    time #{ Order([ Random(O) : i in [1..3] ]) : i in [1..1000] };



    K:=NumberField(x^2-5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    assert forall{z : z in ZBasis(O1) | z in O1 };
    A:=EtaleAlgebra(p);
    OA:=MaximalOrder(A);
    time O1:=Order(Basis(A)); //this should trigger an error
    time O2:=Order(AbsoluteBasis(A));
    assert forall{z : z in ZBasis(O2) | z in O2 };
    for O in [O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;

    
    
    A:=EtaleAlgebra([K,K]);
    time O1:=Order(Basis(A));
    time O2:=Order(AbsoluteBasis(A));
    time O1 eq O2;
    assert forall{z : z in ZBasis(O1) | z in O1 };
    assert forall{z : z in ZBasis(O2) | z in O2 };
    for O in [O1,O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;


    seq:=[NumberField(p),NumberField(x^2-5)];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));
    for O in [O2] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;


    K:=NumberField(x^2-25*5);
    _<y>:=PolynomialRing(K);
    p:=y^2-7;
    E:=NumberField(p); //relative ext
    seq:=[E,E];
    A:=EtaleAlgebra(seq);
    time O2:=Order(AbsoluteBasis(A));
    F,m:=BaseField(A);
    assert F eq K;
    time O1:=Order(Basis(A));//this should trigger an error
    time O3:=OrderOver(Basis(A),EquationOrder(F));
    time O4:=OrderOver(Basis(A),MaximalOrder(F));
    time O3 eq O4;
    time O3 eq O2;
    time O4 eq O2;
    assert forall{ O : O in [O2,O3,O4] | forall{z : z in ZBasis(O) | z in O}};
    for O in [O2,O3,O4] do
        for i in [1..100] do
            assert Random(O) in O;
        end for;
    end for;


*/

