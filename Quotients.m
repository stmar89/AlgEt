/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose Quotients, 1;

/*TODO:

*/


//------------
// Quotients
//------------

intrinsic ResidueField(P::AlgEtIdl) -> FldFin, Map
{ given P a prime of S, returns a finite field F isomorphic to S/P and a surjection (with inverse) S->F.}
    if not assigned P`ResidueField then
        assert IsPrime(P);
        S := Order(P);
        Q,q := ResidueRing(S,P); //q:S->S/P
        size := #Q;
        F := FiniteField(size);
        min_poly := PolynomialRing(Integers())!DefiningPolynomial(F);
        //the following loop is naive
        for y in Q do
            if q(Evaluate(min_poly,y@@q)) eq Zero(Q) then
                prim_elt_inA := y@@q;
                break y;
            end if;
        end for;
        assert assigned prim_elt_inA;
        //now I need to build  the map
        G,gGF := AdditiveGroup(F); //g:G->F
        hGQ := iso<G->Q | [q(prim_elt_inA^i) : i in [0..Degree(min_poly)-1]]>;
        hQG := Inverse(hGQ);
        map := q*hQG*gGF;
	    P`ResidueField:=<F, map>;
    end if;
    return Explode(P`ResidueField);
end intrinsic;

intrinsic QuotientVS(I::Any, J::Any, P::AlgEtIdl) -> ModFld, Map
{
 let I, J, P be fractional R-ideals such that:
 - P is prime of of some order R;
 - J in I and I/J is a vector space over R/P, say of dimension d;
 the function returns the KModule K^d=V and the natural surjection I->V (with pre-image)}
    require {Type(I),Type(J)} subset {AlgEtOrd,AlgEtIdl} : "I and J must be either orders (AlgEtOrd) or ideals (AlgEtIdl)";
    require J subset I : "Teh second argument should be a subset of the first.";
	S := Order(P);
    assert2 P*(Ideal(S,ZBasis(I))) subset Ideal(S,ZBasis(J));
    assert2 S subset MultiplicatorRing(I);
    assert2 S subset MultiplicatorRing(J);
    K,k:=ResidueField(P);
	A := Algebra(S);
	d := Ilog(#K,Integers() ! (Index(J)/Index(I))); // d = dim(I/J) over (S/P)
	V := KModule(K,d);
	//need to find a basis of I/J over R/P.
	zbI := ZBasis(I);
	N := #zbI;
	F := FreeAbelianGroup(N);
	relJ := [F ! cc : cc in AbsoluteCoordinates(ZBasis(J),I)];
    rel:=relJ;
	mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
	mIF := map<A->F| x:-> F ! AbsoluteCoordinates([x],I)[1]>;
	Q,q := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
	bas := [];
	for i in [1..d] do
    //for each iteration of the loop we mod-out from I the S-ideal generated by J and the already found elements of the basis of I/J over S/P
		elt_F := (Q.1@@q);
		elt_I := mFI(elt_F);
		Append(~bas,elt_I);
        rel_i:=[mIF(bb) : bb in ZBasis(Ideal(S,elt_I))];
		rel := rel cat rel_i;
		Q, q := quo<F|rel>; //q:F->Q
	end for;
	assert IsTrivial(Q);
    //function mIV using HNF: bas[i]*S+J eq I. exploit this on ZBasis level to find the S-coordinates of ZBasis(I) wrt bas[i]'s 
    zbJ:=ZBasis(J);
    zbS:=ZBasis(S);
    gens:=&cat[[ b*z: z in zbS ] : b in bas];
    mat:=MatrixAtoQ(gens cat zbJ);
    den:=Denominator(mat);
    dmat:=crQZ(den*mat);
    H,Tr:=HermiteForm(dmat);//Tr*M eq H
    HI,TrI:=HermiteForm(crQZ(den*MatrixAtoQ(zbI)));
    TrI:=crZQ(TrI);
    Tr1:=crZQ(Matrix(Rows(Tr)[1..#zbI]));
    C:=TrI^-1*Tr1;
    new_coords_zbI:=[];
    for k in [1..#zbI] do
        zbIk:=[];
        for i in [0..d-1] do    
            coord_i:=&+[C[k,i*N+j]*zbS[j] : j in [1..#zbS]];
            Append(~zbIk,coord_i);
        end for;
        Append(~new_coords_zbI,zbIk);
    end for;
    mIV:=function(x)
        xinI:=AbsoluteCoordinates([x],I)[1];
        coords_inS:=[ &+[xinI[i]*new_coords_zbI[i][k]: i in [1..#zbI]]  : k in [1..d]];
        coords_inK:=[k(c) : c in coords_inS];
        return &+[coords_inK[i]*V.i : i in [1..d]];
    end function;
	mVI := function(y)
		return &+[ bas[j]*(Eltseq(y)[j]@@k) : j in [1..d] ];
    end function;
    return V, map<A->V | x:->mIV(x), y:->mVI(y) >;
end intrinsic;


intrinsic Quotient(I::AlgEtIdl, J::AlgEtIdl) -> GrpAb, Map
{ given fractional ideals J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J } 
	zbI := ZBasis(I);
	N := #zbI;
	F := FreeAbelianGroup(N);
	rel := [F ! cc : cc in AbsoluteCoordinates(ZBasis(J),I)];
	mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
	mIF := map<A->F| x:-> F ! AbsoluteCoordinates([x],I)[1]>;
	Q,qFQ := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
    q:=map< I->Q | x:->qFQ(mIF(x)) , y:-> mFI(y@@q) >; 
    return Q,q;
end intrinsic;




/* TEST

*/
