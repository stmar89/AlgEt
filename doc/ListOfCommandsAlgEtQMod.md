## List of instrinsics in AlgEtQMod/IntermediateModules.m:

`<b>MinimalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]`
*Given S-modules J subset I, returns the minimal (with respect to inclusion) S-modules M such that J subset M subset I.*

`<b>IntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]`
*Given fractional S-ideals J subset I, returns all the fractional S-ideals K such that J subset K subset I. They are produced recursively using from the minimal ones.*

`<b>MaximalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]`
*Given S-modules J subset I, returns the maximal (with respect to inclusion) S-modules K such that J subset K subset I.*

`<b>IntermediateModulesWithTrivialExtension</b>(I::AlgEtQMod,J::AlgEtQMod,O::AlgEtQOrd)->SetIndx[AlgEtQMod]`
*Given S-modules J subset I, and overorder O of S, it returns all the S-modules N such that J subset N subset I and NO=I. Note: we need O!!I eq I. They are produced recursively using from the maximal ones*


## List of instrinsics in AlgEtQMod/IsomModules.m:

`<b>IsIsomorphic</b>(I::AlgEtQMod,J::AlgEtQMod : Method:="Magma") -> BoolElt`
*Given two modules I and J returns wheater they are isomorphic.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*

`<b>IsomorphismClasses</b>(R::AlgEtQOrd,m::Map : Method:="Magma") -> SeqEnum[AlgEtQMod]`
*Given an order R in some AlgEtQ K, where K acts on some V, by m:K->V, returns representatives of hte isomorphism classes of the S-module lattices in V.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*


## List of instrinsics in AlgEtQMod/Modules.m:

`<b>Module</b>(S::AlgEtQOrd, m::Map, gens::SeqEnum) -> AlgEtQMod`
*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.*

`<b>Module</b>(S::AlgEtQOrd,m::Map,idls::Tup) -> AlgEtQMod`
*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in Components(V), returns the sub-S-module of V generated by the direct sum of the ideals.*

`<b>Print</b>(I::AlgEtQMod)`
*Prints the module.*

`<b>NaturalAction</b>(K::AlgEtQ, V::AlgEtQ)->Map`
*Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.*

`<b>UniverseAlgebra</b>(I::AlgEtQMod) -> AlgEtQ,Map`
*Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).*

`<b>Order</b>(I::AlgEtQMod) -> AlgEtQOrd`
*Returns the order of definition of the module.*

`<b>Generators</b>(I::AlgEtQMod) -> SeqEnum[AlgEtQElt]`
*Returns the generators of the module.*

`<b>ZBasis</b>(I::AlgEtQMod)->SeqEnum[AlgEtQElt]`
*Returns a Z-basis of the module.*

`<b>myHash</b>(I::AlgEtQMod)->RngInt`
*Hash function.*

`<b>'eq'</b>(I::AlgEtQMod,J::AlgEtQMod) -> BoolElt`
*Equality testing.*

`<b>'ne'</b>(I::AlgEtQMod , J::AlgEtQMod ) -> BoolElt`
*Disequality testing.*

`<b>AbsoluteCoordinates</b>(seq::SeqEnum[AlgEtQElt],I::AlgEtQMod) -> SeqEnum`
*AbsoluteCoordiantes with respect to the ZBasis.*

`<b>'in'</b>(x::AlgEtQElt , I::AlgEtQMod ) -> BoolElt`
*Returns if x is in I.*

`<b>'in'</b>(x::RngIntElt , I::AlgEtQMod ) -> BoolElt`
*Returns if x is in I.*

`<b>'in'</b>(x::FldRatElt , I::AlgEtQMod ) -> BoolElt`
*Returns if x is in I.*

`<b>'subset'</b>(I1 :: AlgEtQMod, I2 :: AlgEtQMod) -> BoolElt`
*Checks if the first argument is inside the second.*

`<b>Index</b>(T::AlgEtQMod) -> FldRatElt`
*Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.*

`<b>Index</b>(J::AlgEtQMod, I::AlgEtQMod) -> Any`
*Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].*

`<b>'!!'</b>(T::AlgEtQOrd,I::AlgEtQMod) -> AlgEtQMod`
*Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I.*

`<b>Quotient</b>(I::AlgEtQMod, J::AlgEtQMod) -> GrpAb, Map`
*Given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J.*


