## List of instrinsics in AlgEtQMod/IntermediateModules.m:

> <pre><b>MinimalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</pre>
___*Given S-modules J subset I, returns the minimal (with respect to inclusion) S-modules M such that J subset M subset I.*

> <pre><b>IntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</pre>
___*Given fractional S-ideals J subset I, returns all the fractional S-ideals K such that J subset K subset I. They are produced recursively using from the minimal ones.*

> <pre><b>MaximalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</pre>
___*Given S-modules J subset I, returns the maximal (with respect to inclusion) S-modules K such that J subset K subset I.*

> <pre><b>IntermediateModulesWithTrivialExtension</b>(I::AlgEtQMod,J::AlgEtQMod,O::AlgEtQOrd)->SetIndx[AlgEtQMod]</pre>
___*Given S-modules J subset I, and overorder O of S, it returns all the S-modules N such that J subset N subset I and NO=I. Note: we need O!!I eq I. They are produced recursively using from the maximal ones*


## List of instrinsics in AlgEtQMod/IsomModules.m:

> <pre><b>IsIsomorphic</b>(I::AlgEtQMod,J::AlgEtQMod : Method:="Magma") -> BoolElt</pre>
___*Given two modules I and J returns wheater they are isomorphic.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*

> <pre><b>IsomorphismClasses</b>(R::AlgEtQOrd,m::Map : Method:="Magma") -> SeqEnum[AlgEtQMod]</pre>
___*Given an order R in some AlgEtQ K, where K acts on some V, by m:K->V, returns representatives of hte isomorphism classes of the S-module lattices in V.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*


## List of instrinsics in AlgEtQMod/Modules.m:

> <pre><b>Module</b>(S::AlgEtQOrd, m::Map, gens::SeqEnum) -> AlgEtQMod</pre>
___*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.*

> <pre><b>Module</b>(S::AlgEtQOrd,m::Map,idls::Tup) -> AlgEtQMod</pre>
___*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in Components(V), returns the sub-S-module of V generated by the direct sum of the ideals.*

> <pre><b>Print</b>(I::AlgEtQMod)</pre>
___*Prints the module.*

> <pre><b>NaturalAction</b>(K::AlgEtQ, V::AlgEtQ)->Map</pre>
___*Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.*

> <pre><b>UniverseAlgebra</b>(I::AlgEtQMod) -> AlgEtQ,Map</pre>
___*Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).*

> <pre><b>Order</b>(I::AlgEtQMod) -> AlgEtQOrd</pre>
___*Returns the order of definition of the module.*

> <pre><b>Generators</b>(I::AlgEtQMod) -> SeqEnum[AlgEtQElt]</pre>
___*Returns the generators of the module.*

> <pre><b>ZBasis</b>(I::AlgEtQMod)->SeqEnum[AlgEtQElt]</pre>
___*Returns a Z-basis of the module.*

> <pre><b>myHash</b>(I::AlgEtQMod)->RngInt</pre>
___*Hash function.*

> <pre><b>'eq'</b>(I::AlgEtQMod,J::AlgEtQMod) -> BoolElt</pre>
___*Equality testing.*

> <pre><b>'ne'</b>(I::AlgEtQMod , J::AlgEtQMod ) -> BoolElt</pre>
___*Disequality testing.*

> <pre><b>AbsoluteCoordinates</b>(seq::SeqEnum[AlgEtQElt],I::AlgEtQMod) -> SeqEnum</pre>
___*AbsoluteCoordiantes with respect to the ZBasis.*

> <pre><b>'in'</b>(x::AlgEtQElt , I::AlgEtQMod ) -> BoolElt</pre>
___*Returns if x is in I.*

> <pre><b>'in'</b>(x::RngIntElt , I::AlgEtQMod ) -> BoolElt</pre>
___*Returns if x is in I.*

> <pre><b>'in'</b>(x::FldRatElt , I::AlgEtQMod ) -> BoolElt</pre>
___*Returns if x is in I.*

> <pre><b>'subset'</b>(I1 :: AlgEtQMod, I2 :: AlgEtQMod) -> BoolElt</pre>
___*Checks if the first argument is inside the second.*

> <pre><b>Index</b>(T::AlgEtQMod) -> FldRatElt</pre>
___*Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.*

> <pre><b>Index</b>(J::AlgEtQMod, I::AlgEtQMod) -> Any</pre>
___*Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].*

> <pre><b>'!!'</b>(T::AlgEtQOrd,I::AlgEtQMod) -> AlgEtQMod</pre>
___*Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I.*

> <pre><b>Quotient</b>(I::AlgEtQMod, J::AlgEtQMod) -> GrpAb, Map</pre>
___*Given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J.*


