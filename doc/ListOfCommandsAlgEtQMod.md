## List of instrinsics in AlgEtQMod/IntermediateModules.m:

<p>
<b>MinimalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]
</p>
*Given S-modules J subset I, returns the minimal (with respect to inclusion) S-modules M such that J subset M subset I.*

<p>
<b>IntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]
</p>
*Given fractional S-ideals J subset I, returns all the fractional S-ideals K such that J subset K subset I. They are produced recursively using from the minimal ones.*

<p>
<b>MaximalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]
</p>
*Given S-modules J subset I, returns the maximal (with respect to inclusion) S-modules K such that J subset K subset I.*

<p>
<b>IntermediateModulesWithTrivialExtension</b>(I::AlgEtQMod,J::AlgEtQMod,O::AlgEtQOrd)->SetIndx[AlgEtQMod]
</p>
*Given S-modules J subset I, and overorder O of S, it returns all the S-modules N such that J subset N subset I and NO=I. Note: we need O!!I eq I. They are produced recursively using from the maximal ones*


## List of instrinsics in AlgEtQMod/IsomModules.m:

<p>
<b>IsIsomorphic</b>(I::AlgEtQMod,J::AlgEtQMod : Method:="Magma") -> BoolElt
</p>
*Given two modules I and J returns wheater they are isomorphic.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*

<p>
<b>IsomorphismClasses</b>(R::AlgEtQOrd,m::Map : Method:="Magma") -> SeqEnum[AlgEtQMod]
</p>
*Given an order R in some AlgEtQ K, where K acts on some V, by m:K->V, returns representatives of hte isomorphism classes of the S-module lattices in V.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).*


## List of instrinsics in AlgEtQMod/Modules.m:

<p>
<b>Module</b>(S::AlgEtQOrd, m::Map, gens::SeqEnum) -> AlgEtQMod
</p>
*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.*

<p>
<b>Module</b>(S::AlgEtQOrd,m::Map,idls::Tup) -> AlgEtQMod
</p>
*Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in Components(V), returns the sub-S-module of V generated by the direct sum of the ideals.*

<p>
<b>Print</b>(I::AlgEtQMod)
</p>
*Prints the module.*

<p>
<b>NaturalAction</b>(K::AlgEtQ, V::AlgEtQ)->Map
</p>
*Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.*

<p>
<b>UniverseAlgebra</b>(I::AlgEtQMod) -> AlgEtQ,Map
</p>
*Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).*

<p>
<b>Order</b>(I::AlgEtQMod) -> AlgEtQOrd
</p>
*Returns the order of definition of the module.*

<p>
<b>Generators</b>(I::AlgEtQMod) -> SeqEnum[AlgEtQElt]
</p>
*Returns the generators of the module.*

<p>
<b>ZBasis</b>(I::AlgEtQMod)->SeqEnum[AlgEtQElt]
</p>
*Returns a Z-basis of the module.*

<p>
<b>myHash</b>(I::AlgEtQMod)->RngInt
</p>
*Hash function.*

<p>
<b>'eq'</b>(I::AlgEtQMod,J::AlgEtQMod) -> BoolElt
</p>
*Equality testing.*

<p>
<b>'ne'</b>(I::AlgEtQMod , J::AlgEtQMod ) -> BoolElt
</p>
*Disequality testing.*

<p>
<b>AbsoluteCoordinates</b>(seq::SeqEnum[AlgEtQElt],I::AlgEtQMod) -> SeqEnum
</p>
*AbsoluteCoordiantes with respect to the ZBasis.*

<p>
<b>'in'</b>(x::AlgEtQElt , I::AlgEtQMod ) -> BoolElt
</p>
*Returns if x is in I.*

<p>
<b>'in'</b>(x::RngIntElt , I::AlgEtQMod ) -> BoolElt
</p>
*Returns if x is in I.*

<p>
<b>'in'</b>(x::FldRatElt , I::AlgEtQMod ) -> BoolElt
</p>
*Returns if x is in I.*

<p>
<b>'subset'</b>(I1 :: AlgEtQMod, I2 :: AlgEtQMod) -> BoolElt
</p>
*Checks if the first argument is inside the second.*

<p>
<b>Index</b>(T::AlgEtQMod) -> FldRatElt
</p>
*Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.*

<p>
<b>Index</b>(J::AlgEtQMod, I::AlgEtQMod) -> Any
</p>
*Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].*

<p>
<b>'!!'</b>(T::AlgEtQOrd,I::AlgEtQMod) -> AlgEtQMod
</p>
*Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I.*

<p>
<b>Quotient</b>(I::AlgEtQMod, J::AlgEtQMod) -> GrpAb, Map
</p>
*Given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J.*


