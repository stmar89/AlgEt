## List of instrinsics in AlgEtQMod/IntermediateModules.m:

> <dt><b>MinimalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</dt>
<dd>Given S-modules J subset I, returns the minimal (with respect to inclusion) S-modules M such that J subset M subset I.</dd>

> <dt><b>IntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</dt>
<dd>Given fractional S-ideals J subset I, returns all the fractional S-ideals K such that J subset K subset I. They are produced recursively using from the minimal ones.</dd>

> <dt><b>MaximalIntermediateModules</b>(I::AlgEtQMod,J::AlgEtQMod)->SetIndx[AlgEtQMod]</dt>
<dd>Given S-modules J subset I, returns the maximal (with respect to inclusion) S-modules K such that J subset K subset I.</dd>

> <dt><b>IntermediateModulesWithTrivialExtension</b>(I::AlgEtQMod,J::AlgEtQMod,O::AlgEtQOrd)->SetIndx[AlgEtQMod]</dt>
<dd>Given S-modules J subset I, and overorder O of S, it returns all the S-modules N such that J subset N subset I and NO=I. Note: we need O!!I eq I. They are produced recursively using from the maximal ones</dd>


## List of instrinsics in AlgEtQMod/IsomModules.m:

> <dt><b>IsIsomorphic</b>(I::AlgEtQMod,J::AlgEtQMod : Method:="Magma") -> BoolElt</dt>
<dd>Given two modules I and J returns wheater they are isomorphic.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).</dd>

> <dt><b>IsomorphismClasses</b>(R::AlgEtQOrd,m::Map : Method:="Magma") -> SeqEnum[AlgEtQMod]</dt>
<dd>Given an order R in some AlgEtQ K, where K acts on some V, by m:K->V, returns representatives of hte isomorphism classes of the S-module lattices in V.
The vararg Method allows to choose if the isomorphism testing is done with "Magma", very slow, or with the Hecke/Nemo package for julia, which is much faster.
In the latter case, the Method should be of the form "julia path/to/AlgEtQ/", or if Hecke/Nemo has been built,"julia -J /tmp/Hecke.so ~/path/to/AlgEtQ/" (the ".so" might be different according to your SO. See the documentation of Hecke.Build()).</dd>


## List of instrinsics in AlgEtQMod/Modules.m:

> <dt><b>Module</b>(S::AlgEtQOrd, m::Map, gens::SeqEnum) -> AlgEtQMod</dt>
<dd>Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, returns the sub-S-module of V generated by gens.</dd>

> <dt><b>Module</b>(S::AlgEtQOrd,m::Map,idls::Tup) -> AlgEtQMod</dt>
<dd>Let K and V be AlgEtQ such that m:K->V is a K-module. Given an order S in K, and a tuple of ideals idls in Components(V), returns the sub-S-module of V generated by the direct sum of the ideals.</dd>

> <dt><b>Print</b>(I::AlgEtQMod)</dt>
<dd>Prints the module.</dd>

> <dt><b>NaturalAction</b>(K::AlgEtQ, V::AlgEtQ)->Map</dt>
<dd>Let K=K1x...Kn be a product of distinct number fields, and s1,...,sn be strinctly positive integers. Put V=K1^s1x...xKn^sn. It returns the natural action of K on V, that is, the componentwise diagonal.</dd>

> <dt><b>UniverseAlgebra</b>(I::AlgEtQMod) -> AlgEtQ,Map</dt>
<dd>Returns the Ã©tale algebra in which the module lives, together with the action map:Algebra(Order(I))->UniverseAlgebra(I).</dd>

> <dt><b>Order</b>(I::AlgEtQMod) -> AlgEtQOrd</dt>
<dd>Returns the order of definition of the module.</dd>

> <dt><b>Generators</b>(I::AlgEtQMod) -> SeqEnum[AlgEtQElt]</dt>
<dd>Returns the generators of the module.</dd>

> <dt><b>ZBasis</b>(I::AlgEtQMod)->SeqEnum[AlgEtQElt]</dt>
<dd>Returns a Z-basis of the module.</dd>

> <dt><b>myHash</b>(I::AlgEtQMod)->RngInt</dt>
<dd>Hash function.</dd>

> <dt><b>'eq'</b>(I::AlgEtQMod,J::AlgEtQMod) -> BoolElt</dt>
<dd>Equality testing.</dd>

> <dt><b>'ne'</b>(I::AlgEtQMod , J::AlgEtQMod ) -> BoolElt</dt>
<dd>Disequality testing.</dd>

> <dt><b>AbsoluteCoordinates</b>(seq::SeqEnum[AlgEtQElt],I::AlgEtQMod) -> SeqEnum</dt>
<dd>AbsoluteCoordiantes with respect to the ZBasis.</dd>

> <dt><b>'in'</b>(x::AlgEtQElt , I::AlgEtQMod ) -> BoolElt</dt>
<dd>Returns if x is in I.</dd>

> <dt><b>'in'</b>(x::RngIntElt , I::AlgEtQMod ) -> BoolElt</dt>
<dd>Returns if x is in I.</dd>

> <dt><b>'in'</b>(x::FldRatElt , I::AlgEtQMod ) -> BoolElt</dt>
<dd>Returns if x is in I.</dd>

> <dt><b>'subset'</b>(I1 :: AlgEtQMod, I2 :: AlgEtQMod) -> BoolElt</dt>
<dd>Checks if the first argument is inside the second.</dd>

> <dt><b>Index</b>(T::AlgEtQMod) -> FldRatElt</dt>
<dd>Given an ideal T computes its index with respect to the basis of the algebra of T as a free Z-module.</dd>

> <dt><b>Index</b>(J::AlgEtQMod, I::AlgEtQMod) -> Any</dt>
<dd>Given modules J and I defined over the same order returns [J:I] = [J:J cap I]/[I : J cap I].</dd>

> <dt><b>'!!'</b>(T::AlgEtQOrd,I::AlgEtQMod) -> AlgEtQMod</dt>
<dd>Given an S-module I and an order T, returns the extension IT as a T-module. Note that if T is in S, then IT=I.</dd>

> <dt><b>Quotient</b>(I::AlgEtQMod, J::AlgEtQMod) -> GrpAb, Map</dt>
<dd>Given S-modules J subset I, returns the abelian group Q=I/J together with the quotient map q:I->J.</dd>


