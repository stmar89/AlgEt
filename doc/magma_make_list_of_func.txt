/* vim: set syntax=magma : */

/*
    Magma script to automatically create a .md file with the documentation for all intrinsics.
    It is inspireed by cjdoris magdoc package.

    input:
        - input: = a spec file containing a folder and a sequence of .m files to be scanned
        - output_file:= name of the file returned. It should have extension .md

    It parses the file an looks for "doc-lines".
    These lines are always introduced by /// and followed by either a space, or a specific character/keyword which determines the "type" of the doc-line.
    Here the allowed types, their functions and their formatting:

    type "text":
    /// TEXT is markdown formatted documentation (note the space before TEXT). 
        It has two possible functions:
        - If they appear immediately after a sectioning command (with no intervening space) then they document the section.
        - Otherwise they must be followed by an intrinsic which they document. In this case the parser will ignore the documentation included between braces {xxx}.

    type "sec":    
    ///# NAME define sections. Additional #s give deeper sections.

    type "ditto":
    ///ditto groups this intrinsic with the previous one; typically they have similar inputs and the same return types; when the return types are the same, they are merged in the documentation. The documentation of the "parent" intrinsic can either be specified by a doc-line of type "text" or withing braces {xxx}.

    types "hide-all" and "hide-non":
    all the code between this commands is ignred by the parser.

*/

    is_doc_line:=function(line)
    //returns whether the input line is a doc string. If so, it returns also which type (text, sec, ditto, hide-all,hide-none) and the conten of the line (TEXT when of type "text" or NAME when of type "sec")
        if #line ge 4 and line[1..3] eq "///" and line[4] ne "/" then
            if line[4] eq " " then
                type:="text";
                cnt:=line[4..#line] cat "\n";
                return true,type,cnt;
            elif line[4] eq "#" then
                type:="sec";
                cnt:=line[4..#line] cat "\n";
                return true,type,cnt;
            else
                text:=line[4..#line];
                n:=Index(text," ");
                n:=n eq 0 select #text else n;
                type:=text[1..n];
                assert type in {"hide-all","hide-none","ditto"}; // only these are implemented
                return true,type,"";
            end if;
        else
            return false,"","";
        end if;
    end function;
   
    is_intrinsic:=function(line)
    // determines whether the line is an intrinsc.
        return #line ge 9 and line[1..9] eq "intrinsic";
    end function;

    is_end_intrinsic:=function(line)
    // determines whether the line is the end of an intrinsc.
        return #line ge 13 and line[1..13] eq "end intrinsic";
    end function;

    parse_intrisic:=function(lines)
    // given a sequnce of lines containing the code of an intrinsic (the first one starts with "intrinsic" while the last one is "end intrinsc"), returns two strings in markdown formatting: the first is the name in bold plus input and ouput types; the second is the description of the intrinsic contained between the braces.
        name:=lines[1][Index(lines[1]," ")..Index(lines[1],"(")-1];
        name_in_out:="<pre><b>" cat name cat "</b>" cat lines[1][Index(lines[1],"(")..#lines[1]] cat "</pre>\n";
        rest:=Join(lines[2..#lines],"\n");
        rest:=rest[Index(rest,"{")+1..#rest];
        e:=0;
        for i in [1..#rest] do
            if rest[i] eq "}" and i gt 1 and rest[i-1] ne "\\" then
                e:=i-1;
                break i;
            end if;
        end for;
        braces:=Trim(rest[1..e]) cat "\n";
        return name_in_out,braces;
    end function;

    spec:=Split(Read(input),"{\n}");
    fld:=spec[1];
    output:="";
    braces:="";
    for dot_m in spec[2..#spec] do
        path_dot_m:=fld cat "/" cat dot_m;
        lines:=Split(Read("../" cat path_dot_m):IncludeEmpty);
        i:=1; 
        last:=#lines;
        use_in_braces_for_next_intrinsic:=true; // this will be turned to false if ditto or 
                                                // external doc is found
        repeat
            is_doc,type,cnt:=is_doc_line(lines[i]);
            if is_doc then
                if type eq "hide-all" then
                    // we ignore everything until hide-none
                    repeat
                        i+:=1;
                        is_doc,type,cnt:=is_doc_line(lines[i]);
                    until is_doc and type eq "hide-none";
                elif type eq "sec" then
                    output cat:=cnt;
                    // it might be followed by a bunch of doc_lines of type text.
                    // if so, we read the doc and place the counter an the last line of the doc.
                    // otherwise we do nothing.
                    doc:=true;
                    repeat
                        i+:=1;
                        is_doc,type,cnt:=is_doc_line(lines[i]);
                        if is_doc and type in {"text","sec"} then
                            output cat:=cnt;
                        else 
                            // end of doc
                            doc:=false;
                            i-:=1;
                        end if;
                    until not doc;
                elif type eq "ditto" then
                    // it must be followed by an intrinsic
                    // while parsing the following intrinsc, we ignore the doc in braces and use the 
                    // previously stroed one, which is in the variable "braces".
                    assert is_intrinsic(lines[i+1]);
                    assert braces ne "";
                    use_in_braces_for_next_intrinsic:=false;
                    // remove the previous description from output
                    num_lines_to_remove:=#Split(braces);
                    output:=Split(output);
                    output:=Join(output[1..#output-num_lines_to_remove],"\n");
                    doc_next_intrinisc:=braces;
                elif type eq "text" then
                    use_in_braces_for_next_intrinsic:=false;
                    doc_next_intrinisc:=cnt;
                    doc:=true;
                    repeat
                        i+:=1;
                        is_doc,type,cnt:=is_doc_line(lines[i]);
//i,is_doc;
                        if is_doc and type eq "text" then
                            doc_next_intrinisc cat:=cnt;
//doc_next_intrinisc;
                        else 
                            // end of doc
                            doc:=false;
                            i-:=1;
                        end if;
                    until not doc;
//i;
                    assert is_intrinsic(lines[i+1]);
                end if;
            elif is_intrinsic(lines[i]) then
                lines_intrisic:=[ lines[i] ];
                repeat
                    i+:=1;
                    Append(~lines_intrisic,lines[i]);
                until is_end_intrinsic(lines[i]);
                name_in_out,braces:=parse_intrisic(lines_intrisic); // already formatted
                output cat:=name_in_out;
                if not use_in_braces_for_next_intrinsic then
                    braces:=doc_next_intrinisc;
                end if;
                output cat:=braces;
                use_in_braces_for_next_intrinsic:=true; // this will be turned to false if ditto or 
                                                        // external doc is found
            end if;

            // we move to the next line
            i+:=1;
        until i gt last;
    end for;


    output:=SubstituteString(output,"*","\*");
    //TODO check for characters to escape
    //print output;
    fprintf output_file,"%o",output;
    quit;









/* OLD stuff

    clean:=function(str0)
    // removes "\n" and " " from the beginning and the end of the string;
    // replaces * with \*
        str:=str0;
        for i in [1,2] do
            while str[#str] in {"\n"," "} do
                Prune(~str);
            end while;
            str:=Reverse(str);
        end for;
        return str;
    end function;

    find_next:=function(inp,pos,str);
        //find the next occurrence in inp of str. returns the position of the character right after str.
        // if Eof is reached returns 0;
        assert pos gt 0;
        if pos eq #inp then
            return 0;
        end if;
        while inp[pos] ne str[1] do
            pos+:=1;
            if pos eq #inp then
                return 0;
            end if;
        end while;
        n:=#str-1;
        while not inp[pos..pos+n] eq str do
            if pos+n+1 gt #inp then
                return 0;
            end if;
            pos +:=1;
        end while;
        return pos+n+1;
    end function;

    find_next_intrinsic:=function(inp,pos)
    // returns name,name_2,descr, pos
    // where: name is the intrinsic, name_2 is the rest of the line, descr is what is contained b/w {..},
    // and pos is the position of the next 'intrinsic', if any, or 0 for Eof
        assert pos gt 0;
        name_in:=find_next(inp,pos,"intrinsic");
        if name_in eq 0 then return "","","",0; end if; //we hit the Eof
        name_out:=find_next(inp,name_in,"(")-2;
        name:=inp[name_in..name_out];
        name:=clean(name);
        end_name:=find_next(inp,name_out+1,"\n")-2;
        name_2:=clean(inp[name_out+1..end_name]);
        desc_in:=find_next(inp,name_out,"{");
        desc_out:=find_next(inp,desc_in,"}")-2;
        desc:=clean(inp[desc_in..desc_out]);
        desc:=SubstituteString(desc,"*","\\*");
        end_int:=find_next(inp,desc_out+1,"intrinsic");
        return name,name_2,desc,end_int; 
    end function;

    input:=Split(Read(input),"{\n}");
    fld:=input[1];
    for input_file0 in input[2..#input] do
        input_file:=fld cat "/" cat input_file0;
        inp:=Read("../" cat input_file);
        out:="";
        pos:=1;
        repeat
            name,name_2,desc,pos:=find_next_intrinsic(inp,pos);
            if pos ne 0 then
                out cat:="> <pre><b>" cat name cat "</b>" cat name_2 cat "</pre>\n" cat 
                "<em>" cat desc cat "</em>\n\n";
            end if;
        until pos eq 0;
        fprintf output_file,"## List of instrinsics in %o:\n\n%o\n",input_file,out;
    end for;
     
