/* vim: set syntax=magma :*/

/////////////////////////////////////////////////////
// Stefano Marseglia, Utrecht University, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
/////////////////////////////////////////////////////

/*
    Here you can find the code to reproduce the examples in the papers:
    - [1] "Computing the ideal class monoid of an order",
        J. Lond. Math. Soc. 101 (2020), no. 3, 984-1007
        Stefano Marseglia
        https://doi.org/10.1112/jlms.12294
        https://arxiv.org/abs/1805.09671
    
    - [2] "Cohen-Macaulay type of orders, generators and ideal classes",
        Stefano Marseglia
        https://arxiv.org/abs/2206.03758
*/

// ########################
// ### [1, Example 7.1] ###
// ########################

AttachSpec("~/packages_github/AlgEt/spec");

P<x>:=PolynomialRing(Integers());
f:=x^3+31*x^2+43*x+77;
A:=EtaleAlgebra(f);
// we define E=Z[x]/(f) and the maximal order of A
O:=MaximalOrder(A);
E:=EquationOrder(A);
Index(O,E);
// the Picard Group of E
E_pic:=PicardGroup(E);
#E_pic;
// we compute the ideal classes of fractional ideals with multiplicator ring equal to E
E_icm_bar:=ICM_bar(E);
#E_icm_bar;
// since E is monogenic we know that it is Gorenstein, but it is not Bass, that is there is at least one over-order which is not Gorenstein
IsGorenstein(E);
IsBass(E);
//and hence we get that there are no other fractional ideals I with (I:I)=E other than the invertible ones.
#E_pic eq #E_icm_bar;
// We now compute the over-orders of E
E_over_orders:=FindOverOrders(E);
#E_over_orders;
// and the weak equivalence classes of all fractional E-ideals
E_wk:=WKICM(E);
#E_wk;
// and all the ideal classes of E
E_icm:=ICM(E);
#E_icm;
// For each over_order we compute the index, the weak equivalence classes, the Picard group and the number of isomorphism classes with that multiplicator ring:
for S in E_over_orders do
    Index(O,S), #WKICM_bar(S), #PicardGroup(S), #ICM_bar(S);
end for;

// ########################
// ### [1, Example 7.2] ###
// ########################

AttachSpec("~/packages_github/AlgEt/spec");

P<x>:=PolynomialRing(Integers());
f:=x^3-1000*x^2-1000*x-1000;
A:=EtaleAlgebra(f);
// we define E=Z[x]/(f) and the maximal order of A
O:=MaximalOrder(A);
E:=EquationOrder(A);
Index(O,E);
// The singular primes of E are:
PrimesAbove(Conductor(E));
// We now compute the over-orders of E
E_over_orders:=FindOverOrders(E);
#E_over_orders;
// and the weak equivalence classes of all fractional E-ideals
E_wk:=WKICM(E);
#E_wk;
// Computing ICM(E) directly will take a lot of time, since generating all the ideals is a costly computation (some PicardGroups are very big!) Instead we just compute the size, as follows.

size_icm_E:=0;
// For each over_order we compute the index, the weak equivalence classes, the Picard group and the number of isomorphism classes with that multiplicator ring:
for S in E_over_orders do
    Index(O,S), #WKICM_bar(S), #PicardGroup(S);
    size_icm_E +:=#WKICM_bar(S)*#PicardGroup(S);
end for;
// We deduce that ICM(E) consists of this many classes:
size_icm_E;


// ########################
// ### [1, Example 7.3] ###
// ########################

AttachSpec("~/packages_github/AlgEt/spec");

P<x>:=PolynomialRing(Integers());
f1:=x^2+4*x+7;
f2:=x^3-9*x^2-3*x-1;
// Consider the Ã©tale algebras generated by f1 and f2, and the corresponding equation orders:
K1:=EtaleAlgebra(f1);
K2:=EtaleAlgebra(f2);
R1:=EquationOrder(K1);
O1:=MaximalOrder(K1);
R2:=EquationOrder(K2);
O2:=MaximalOrder(K2);
IsBass(R1);
#ICM(R1);
IsBass(R2);
#ICM(R2);

// Now we consider the product:
K:=EtaleAlgebra(f1*f2);
R:=EquationOrder(K);
IsProductOfOrders(R);
O:=MaximalOrder(K);
Index(O,R);
// Note that R has many overorders:
#FindOverOrders(R);
// We compute the weak equivalence classes of R
#WKICM(R);
// and the size of ICM(R), by looping over the overorders:
size_icm_R:=0;
for S in FindOverOrders(R) do
    Index(O,S), #WKICM_bar(S), #PicardGroup(S);
    size_icm_R +:=#WKICM_bar(S)*#PicardGroup(S);
end for;
size_icm_R;

// ########################
// ### [2, Example 6.6] ###
// ########################

AttachSpec("~/packages_github/AlgEt/spec");

P<x>:=PolynomialRing(Integers());
f:=x^6-6*x^5+6*x^4+43*x^3+96*x^2-1536*x+4096;
K:=EtaleAlgebra(f);
pi:=PrimitiveElement(K);
S:=Order([pi]); // the equation order
O:=MaximalOrder(K);
pp:=PrimesAbove(Conductor(S));
// We compute the dimension of O/P*O over S/P for the singular P's:
O1:=S!!OneIdeal(O);
for P in pp do
    Ilog(Index(S,P),Index(O1,P*O1));
end for;
// Hence among the overorders of S, there is one with CohenMacaulayType equal to 2, which is the maximum.
oo:=FindOverOrders(S);
[ CohenMacaulayType(T) : T in oo ];
// We compute the weak equivalence classes of S
#WKICM(S);
// and the size of ICM(S), by looping over the overorders:
size_icm_S:=0;
for T in FindOverOrders(S) do
    Index(O,T), #WKICM_bar(T), #PicardGroup(T);
    size_icm_S +:=#WKICM_bar(T)*#PicardGroup(T);
end for;
size_icm_S;

// If we instead consider the order Z[pi,16/pi] we get:
R:=Order([pi,16/pi]);
size_icm_R:=0;
for T in FindOverOrders(R) do
    Index(O,T), #WKICM_bar(T), #PicardGroup(T);
    size_icm_R +:=#WKICM_bar(T)*#PicardGroup(T);
end for;
size_icm_R;

quit;
